## 资源文件概述
K8s中的基本概念和术语大多是围绕资源对象来说的，总体上分为两类
1. 某种资源的对象：节点、Pod、服务、Volume等
2. 与资源对象相关的事物和动作：标签、注解、命名空间、Deployment、HPA、PVC等

资源对象一般有以下几个通用属性：
1. 版本
2. 类别
3. 名称
4. 标签
5. 注解

我们可以采用`YAML`或者`JSON`格式声明一个资源对象，每个资源对象都有自己的特定结构定义，并且统一报存在`etcd`这种非关系型数据库中，以实现最快的读写速度。此外，所有资源对象都可以通过`kubectl`工具进行增删改查。

一些资源对象有自己的生命周期以及相应的状态，比如Pod的`Pending`、`Running`等。

下面是资源对象更详细的讲解：

### 集群类
集群表示一个由 Master 和 Node组成的 K8s 集群

#### Master
集群的控制节点，每个集群都有一个或者一组Master节点来负责整个集群的管理和控制，通常占用一个独立的服务器。

在Master上运行着以下关键进程：
1. `API Server`：提供`HTTP RESTful API`接口的服务，资源增删改查的唯一入口，集群控制的入口
2. `Controller Manager`：所有资源对象的自动化控制中心
3. `Scheduler`：负责资源调度的进程
4. `etcd`：非关系型数据库

#### Node
集群中除了Master意外的其他服务器被称为Node，可以是物理主机也可以是虚拟机。作为集群中的工作负载节点，每个Node会被Master分配一些工作负载，某个Node宕机的时候，其上的工作负载会被Master自动转移到其他Node上。

在Node上运行着以下关键进程：
1. `kubelet`：Pod对应容器的创建、启停等任务，与Master密切协作实现集群管理的基本功能
2. `kube-proxy`：实现Service的通信和负载均衡机制的任务
3. 容器运行时：负责本机的容器创建和管理

Node可以动态增加，只要配置了上述关键进程。默认情况下，`kubelet`会向Master注册自己，一旦Node被纳入集群管理范畴，`kubelet`进程就会定时向Master汇报自身的情况，如操作系统、CPU和内存使用情况，有哪些pod在运行等。这样Master就可以获知每个Node的资源使用情况，并实现高效的负载均衡调度策略。Node超时不上报信息则会被判定为失联，Master会进行工作负载的转移。

查看Node：
```bash
kubectl get nodes
```

查看Node详细信息：
```bash
kubectl describe node <node name>
```

Node启动之后会进行一系列自检工作，一切正常的时候才设置为Ready状态，即健康状态，Master 可以在其上调度新的任务。如果Node存在问题，比如安全问题、资源不足或者计划淘汰，就给Node打上特别的污点`Taint`标签，避免新的容器调度到上面。Pod可以选择容忍`Toleration`这些污点，就可以继续调度到有污点的Node上。

集群类里还有命名空间的概念，用来实现多租户的资源隔离。一个集群可以创建多个命名空间，每个命名空间都是相互独立的存在，不同命名空间的资源对象从逻辑上相互隔离。集群中Master会自动创建两个命名空间：`default`和`kube-system`。用户创建的资源对象会默认放到`default`中，而系统相关的资源对象，比如网络组件、监控类组建会放在`kube-system`中。不同的命名空间可以结合资源配额管理，限定不同租户占用的资源。

### 应用类
#### Service
一般来说，Service指的是无状态服务，通常由多个程序副本提供服务，特殊情况下也可以是有状态的单实例服务。K8S中的服务具有一个全局唯一的虚拟ClusterIP地址，在Service创建之后被分配，并且整个生命周期都不变。客户端可以通过这个IP地址和服务的端口号来访问服务，也可以通过集群的DNS服务实现域名到IP地址的DNS映射功能。这样就解决了服务发现的问题，还进一步实现了Service的透明负载均衡和故障自动恢复的高级特性。服务之间也可以配合，我们的系统最终可以由多个提供不同业务能力又彼此独立的微服务单元组成。

#### Pod
Pod是最重要的基本概念之一，每个Pod都有一个特殊的被称为根容器的Pause容器，其对应的镜像属于K8S平台的一部分，每个Pod还包含着其他一个或者多个用户的业务容器。

为什么要有Pod概念呢？
1. 作为基本的调度、复制等管理的最小单位，让多个应用进程可以一起有效的调度和伸缩
2. Pod的多个业务容器共享Pause容器的IP和Volume，解决了业务容器之间的通信和文件共享问题

每个Pod都被分配了唯一的Pod IP，K8S要求底层网络支持集群内任意两个Pod之间的TCP/IP通信，这通常采用虚拟二层网络技术实现，因此一个Pod里的容器与另外主机上的Pod容器可以直接通信。

普通的Pod会被放入etcd中存储，随后被Master调度到某个具体的Node上并绑定，Node上的Kublet进程会将Pod实例化为一组相关的Docker容器并启动。当Pod里的某个容器停止时，集群会检测到并且重启整个Pod，如果Node宕机，则Pod会调度到其他Node上。

静态的Pod没有放在etcd中存储，而是存放在某个具体的Node的具体文件中，只能在这个Node上启动和运行。

#### EndPoint
Pod本身的IP和Pod中一个容器的端口组成了EndPoint，代表此Pod里的一个服务进程对外通信地址。

#### Pod Volume
Docker Volume对应到K8S中就是Pod Volume，他被定义在Pod上，然后被各个容器挂载到自己的文件系统中的。

#### Event
Event是一个事件的记录，通常被关联到某个具体的资源对象上，是排查故障的重要参考信息。

#### Label与标签选择器
一个Label就是一个键值对，可以被附加到各种资源对象上，一个资源对象可以定义任意数量的Label，同一个Label也可以添加到任意数量的资源对象上。Label通常在资源对象定义时确定，也可以在对象创建后动态添加或者删除。通过给资源对象捆绑标签，可以实现多维度的分组管理，更好的进行资源的管理。常用的Label如下：
1. 版本标签
2. 环境标签
3. 架构标签
4. 分区标签
5. 质量管控标签

给某个资源定一个一个Label之后，可以通过标签选择器来查询和筛选拥有某些标签的资源对象。可以用基于等式的Selector表达式或者基于集合的Selector表达式来实现类似SQL的对象查询。

通过给Pod打上标签，并配置Service的标签选择器，就可以将Pod和Service联系到一起。

#### Deployment
