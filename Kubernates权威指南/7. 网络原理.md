## K8S 网络模型
基础原则：每个Pod都拥有一个独立的IP地址，并假定所有Pod都在一个可以直接连通的、扁平的网络空间中。所以不管谁否运行在同一个Node中，都可以直接通过对方的IP通信。在K8S世界，IP以Pod为单位进行分配，一个Pod内部的所有容器共享一个网络堆栈，这个模型叫做`IP-per-Pod`模型。

同一个Pod的不同容器共享一个网络命名空间，也就是同一个Linux协议栈，因此一个Pod内的容器可以通过`localhost`直接访问别人的端口，隔离性更小了，通信会更高效。与动态端口映射方式相比，可以减少配置的复杂化，更好的进行DNS解析、服务注册与发现，因为服务可以知道自己对外暴露的真实服务IP和端口。

## docker 网络基础知识
1. 网络命名空间
2. Veth 设备对：在不同的网络空间中进行通信，原理为一对连接的网卡分别放在两个命名空间中
3. 网桥：二层虚拟网络设备
4. iptables和Netfilter：对数据包进行操作的回调函数挂接点
5. 路由

## docker 的网络实现
这里只介绍bridge模式。

Docker daemon首次启动时会创建一个虚拟网桥docker0，然后在私有网络空间中给这个网桥分配一个子网。针对Docker创建的每一个容器都创建一个Veth 设备对，一端在网桥docker0上，一端使用网络命名空间映射到容器内的eth0设备，然后在网桥的地址段内给eth0接口分配一个IP地址。

这里涉及三个IP地址：
1. 主机的网卡IP地址
2. 网桥docker0的IP地址
3. 容器内eth0的IP地址，与docker0不在同一个网段上

数据包从主机的网卡通过路由转发给网桥docker0，然后再通过Veth设备对传递给容器。这样外部是看不到docker0的IP地址和容器内eth0的IP地址的。这样为了让不同主机上的容器可以相互通信，就必须在主机的地址上分配端口，然后将这个端口的流量路由或者代理到目标容器上。
![](7.%20网络原理/Pasted%20image%2020220801143554.png)
## K8S 的网络实现
主要解决这些问题：
1. 容器与容器之间的直接通信
2. 抽象的Pod到Pod之间的通信
3. Pod到Service之间的通信
4. 集群内部与外部组件的通信

### 容器到容器
同一个Pod的容器共享一个网络命名空间，共享一个Linux协议栈。所以对于网络上的操作就和在一台机器上一样，甚至可以用`localhost`来访问彼此的端口。
![](7.%20网络原理/Pasted%20image%2020220801145315.png)
### Pod之间的通信
每一个Pod都有一个真实的全局IP地址，同一个Node内的不同Pod可以直接用对方的IP地址通信，而且不需要其他的发现机制。

#### 同一个Node上Pod的通信
两个Pod都是通过Veth连接到同一个docker0网桥的，他们的IP地址都是从docker0的网段上动态获取的，和网桥的IP属于一个网段。Pod的默认路由也都是docker0的地址，所有的非本地地址的网络数据都会默认发送到docker0网桥上进行中转。
![](7.%20网络原理/Pasted%20image%2020220801144055.png)
#### 不同Node上Pod的通信
要满足两个条件：
1. 整个集群中Pod的IP不能冲突
2. 要将Pod的IP和Node所在的IP关联起来

首先在部署集群时需要对docker0的IP地址进行规划，保证每个Node上的docker0地址都没有冲突。

然后Pod的数据发出之后，需要先发到相应Node的网卡上，然后通过路由转发到具体的docker0上，再中转到相应的Pod。这种Pod和其对应的Node的IP地址的映射就需要额外的网络配置和组件来完成了。
![](7.%20网络原理/Pasted%20image%2020220801145449.png)
