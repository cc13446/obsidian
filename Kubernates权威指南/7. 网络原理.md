## K8S 网络模型
基础原则：每个Pod都拥有一个独立的IP地址，并假定所有Pod都在一个可以直接连通的、扁平的网络空间中。所以不管谁否运行在同一个Node中，都可以直接通过对方的IP通信。在K8S世界，IP以Pod为单位进行分配，一个Pod内部的所有容器共享一个网络堆栈，这个模型叫做`IP-per-Pod`模型。

同一个Pod的不同容器共享一个网络命名空间，也就是同一个Linux协议栈，因此一个Pod内的容器可以通过`localhost`直接访问别人的端口，隔离性更小了，通信会更高效。与动态端口映射方式相比，可以减少配置的复杂化，更好的进行DNS解析、服务注册与发现，因为服务可以知道自己对外暴露的真实服务IP和端口。

## docker 网络基础知识
1. 网络命名空间
2. Veth 设备对：在不同的网络空间中进行通信，原理为一对连接的网卡分别放在两个命名空间中
3. 网桥：二层虚拟网络设备
4. iptables和Netfilter：对数据包进行操作的回调函数挂接点
5. 路由

## docker 的网络实现
这里只介绍bridge模式。

Docker daemon首次启动时会创建一个虚拟网桥docker0，然后在私有网络空间中给这个网桥分配一个子网。针对Docker创建的每一个容器都创建一个Veth 设备对，一端在网桥docker0上，一端使用网络命名空间映射到容器内的eth0设备，然后在网桥的地址段内给eth0接口分配一个IP地址。

这里涉及三个IP地址：
1. 主机的网卡IP地址
2. 网桥docker0的IP地址
3. 容器内eth0的IP地址，与docker0不在同一个网段上

数据包从主机的网卡通过路由转发给网桥docker0，然后再通过Veth设备对传递给容器。这样外部是看不到docker0的IP地址和容器内eth0的IP地址的。这样为了让不同主机上的容器可以相互通信，就必须在主机的地址上分配端口，然后将这个端口的流量路由或者代理到目标容器上。
![](7.%20网络原理/Pasted%20image%2020220801143554.png)
## K8S 的网络实现
主要解决这些问题：
1. 容器与容器之间的直接通信
2. 抽象的Pod到Pod之间的通信
3. Pod到Service之间的通信
4. 集群内部与外部组件的通信

### 容器到容器
同一个Pod的容器共享一个网络命名空间，共享一个Linux协议栈。所以对于网络上的操作就和在一台机器上一样，甚至可以用`localhost`来访问彼此的端口。
![](7.%20网络原理/Pasted%20image%2020220801145315.png)
### Pod之间的通信
每一个Pod都有一个真实的全局IP地址，同一个Node内的不同Pod可以直接用对方的IP地址通信，而且不需要其他的发现机制。

#### 同一个Node上Pod的通信
两个Pod都是通过Veth连接到同一个docker0网桥的，他们的IP地址都是从docker0的网段上动态获取的，和网桥的IP属于一个网段。Pod的默认路由也都是docker0的地址，所有的非本地地址的网络数据都会默认发送到docker0网桥上进行中转。
![](7.%20网络原理/Pasted%20image%2020220801144055.png)
#### 不同Node上Pod的通信
要满足两个条件：
1. 整个集群中Pod的IP不能冲突
2. 要将Pod的IP和Node所在的IP关联起来

首先在部署集群时需要对docker0的IP地址进行规划，保证每个Node上的docker0地址都没有冲突。

然后Pod的数据发出之后，需要先发到相应Node的网卡上，然后通过路由转发到具体的docker0上，再中转到相应的Pod。这种Pod和其对应的Node的IP地址的映射就需要额外的网络配置和组件来完成了。
![](7.%20网络原理/Pasted%20image%2020220801145449.png)
## 从 Service 到容器的网络过程
1. 创建一个服务监听80端口
2. 集群给服务分配虚拟IP：`20.1.244.75`，可以是任何段，因为不在物理网络上路由，不冲突就行
3. kubeProxy服务给每一个新创建的服务都关联一个随机的端口号并监听，这里是`33761`
4. 写入iptables重定向规则，将`20.1.244.75:80`重定向到`33761`端口
5. 当客户端访问`20.1.244.75:80`，就会被重定向到kube-proxy
6. kubeProxy进行负载均衡，选择一个Pod进行转发

## CNI 网络模型
`Container Network Interface`是CoreOS公司提出的，`Container Network Modle`是Docker公司提出的。这两个主流容器网络模型都是为了实现容器网络的更高要求：容器固定IP地址、一个容器多个IP地址、多个子网隔离、ACL控制策略、与SDN集成等。

### CNM 模型简介
CNM主要通过三个组件实现：
1. `Network Sandbox`：容器内部的网络栈，可以包含多个`Endpoint`
2. `Endpoint`：将容器内的`Sandbox`与外部网络相连的网络接口，一个`Endpoint`只能加入一个`network`
3. `Network`：可以直接互联的`Endpoint`集合

### CNI 网络模型详解
CNI定义了容器运行环境与网络插件之间的简单接口规范，通过一个Json Schema定义CNI插件提供的输入输出参数。一个容器可以通过绑定多个网络插件加入多个网络中。