## 五种IO模型

### 1. 阻塞式 I/O

应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。

![](Netty/Pasted%20image%2020230723225803.png)

### 2. 非阻塞式 I/O

应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成。

![](Netty/Pasted%20image%2020230723233245.png)

### 3. I/O 复用

使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。

如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。

![](Netty/Pasted%20image%2020230723233459.png)

更多的参考[NIO](../Linux/NIO.md)

### 4. 信号驱动 I/O

应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。

![](Netty/Pasted%20image%2020230723233854.png)

### 5. 异步 I/O

进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。

![](Netty/Pasted%20image%2020230723234008.png)

### 比较

同步和异步
- 同步 I/O: 应用进程在调用 recvfrom 操作时会阻塞，要从内核复制数据
- 异步 I/O: 内核负责复制数据

![](Netty/Pasted%20image%2020230723234212.png)