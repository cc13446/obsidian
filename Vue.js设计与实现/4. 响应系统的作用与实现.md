## 响应式数据与副作用函数
副作用函数：执行会直接或者间接的产生副作用的函数。
响应式数据：某个值变化后，副作用函数自动执行

## 响应式数据的基本实现
拦截一个对象的读取和设置操作。

当读取对象时，将副作用函数储存到一个桶里
![](4.%20响应系统的作用与实现/Pasted%20image%2020221217204136.png)
当设置对象的值时，把副作用对象从桶里取出并执行。
![](4.%20响应系统的作用与实现/Pasted%20image%2020221217204241.png)
ES2015之前通过`Object.defineProperty`函数拦截一个对象属性的读取和设置操作，也就是Vue2的实现方式。目前我们可以使用代理对象`proxy`来实现。
```javascript
// 存储副作用函数的桶
const bucket = new Set()

// 原始数据
const data = { text: 'hello world' } 
// 对原始数据的代理
const obj = new Proxy(data, {

	// 拦截读取操作
	get(target, key) {
		// 将副作用函数 effect 添加到存储副作用函数的桶中 
		bucket.add(effect)
		// 返回属性值
		return target[key]
	},
	// 拦截设置操作
	set(target, key, newVal) {
		// 设置属性值
		target[key] = newVal
		// 把副作用函数从桶里取出并执行 
		bucket.forEach(fn => fn())
		// 返回 true 代表设置操作成功 
		return true
	}
})
```

## 创建一个完善的响应系统
1. 提供一个用来注册副作用函数的机制
2. 每个对象都应该有自己的桶：`WeakMap<Target, Map<Key, Set<Effect>>>`

```js
const obj = new Proxy(data, {
	// 拦截读取操作
	get(target, key) {
		// 将副作用函数 activeEffect 添加到存储副作用函数的桶中 
		track(target, key)
		// 返回属性值
		return target[key]
	},
	// 拦截设置操作
	set(target, key, newVal) {
		// 设置属性值
		target[key] = newVal
		// 把副作用函数从桶里取出并执行
		trigger(target, key)
	} 
})

// 在 get 拦截函数内调用 track 函数追踪变化
function track(target, key) {
	// 没有 activeEffect，直接 return
	if (!activeEffect) return
	let depsMap = bucket.get(target)
	if (!depsMap) {
		bucket.set(target, (depsMap = new Map()))
	}
	let deps = depsMap.get(key)
	if (!deps) {
		depsMap.set(key, (deps = new Set()))
	}
	deps.add(activeEffect)
}
// 在 set 拦截函数内调用 trigger 函数触发变化
function trigger(target, key) {
   const depsMap = bucket.get(target)
   if (!depsMap) return
   const effects = depsMap.get(key)
   effects && effects.forEach(fn => fn())
}
```

## 分支切换与cleanup
分支切换：在 `effectFn` 函数内部存在一个三元表达式，根据字段 `obj.ok` 值的不同会执行不同的代码分支。当字段 `obj.ok` 的值发生变化时， 代码执行的分支会跟着变化。
```javascript
const data = { ok: true, text: 'hello world' }
const obj = new Proxy(data, { /* ... */ })

effect(function effectFn() {
	document.body.innerText = obj.ok ? obj.text : 'not'
})
```

字段`obj.ok`的初始值为`true`，这时会读取字段`obj.text`的值， 所以当`effectFn`函数执行时会触发字段 `obj.ok`和字段`obj.text`这两个属性的读取操作
![](4.%20响应系统的作用与实现/Pasted%20image%2020221217210739.png)
这样当`object.ok`设置为`false`时，`object.text`没被读取，这样就会产生遗留的副作用函数，实际上理想情况下，副作用函数`effectFn`不应该被字段`obj.text`所对应的依赖集合收集，如下图：
![](4.%20响应系统的作用与实现/Pasted%20image%2020221217210856.png)
遗留的副作用函数会导致不必要的更新，解决这个问题的思路很简单，每次副作用函数执行时，我们可以 先把它从所有与之关联的依赖集合中删除。当副作用函数执行完毕后，会重新建立联系，但在新的联系中不会包含遗留的副作用函数。
![](4.%20响应系统的作用与实现/Pasted%20image%2020221217211547.png)
重新设计副作用函数，在`effect`内部我们定义了新的`effectFn`函数，并为其添加了`effectFn.deps`属性，该属性是一个数组，用来存储所有包含当前副作用函数的依赖集合。
![](4.%20响应系统的作用与实现/Pasted%20image%2020221217213403.png)
```js
const obj = new Proxy(data, {
	// 拦截读取操作
	get(target, key) {
		// 将副作用函数 activeEffect 添加到存储副作用函数的桶中 
		track(target, key)
		// 返回属性值
		return target[key]
	},
	// 拦截设置操作
	set(target, key, newVal) {
		// 设置属性值
		target[key] = newVal
		// 把副作用函数从桶里取出并执行
		trigger(target, key)
	} 
})

// 用一个全局变量存储被注册的副作用函数
let activeEffect
function effect(fn) {
	const effectFn = () => {
		// 调用 cleanup 函数完成清除工作 
		cleanup(effectFn) // 新增
		// 当 effectFn 执行时，将其设置为当前激活的副作用函数
		activeEffect = effectFn
		fn()
	}
	// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合
	effectFn.deps = []
	// 执行副作用函数
	effectFn()
}

// track中记录deps
function track(target, key) {
	// 没有 activeEffect，直接 return
	if (!activeEffect) return
	let depsMap = bucket.get(target)
	if (!depsMap) {
		bucket.set(target, (depsMap = new Map()))
	}
	let deps = depsMap.get(key)
	if (!deps) {
		depsMap.set(key, (deps = new Set()))
	}
	// 把当前激活的副作用函数添加到依赖集合 deps 中
	deps.add(activeEffect)
	// deps 就是一个与当前副作用函数存在联系的依赖集合
	// 将其添加到 activeEffect.deps 数组中
	activeEffect.deps.push(deps) // 新增
}

// 清理
function cleanup(effectFn) {
	// 遍历 effectFn.deps 数组
	for (let i = 0; i < effectFn.deps.length; i++) {
		// deps 是依赖集合
		const deps = effectFn.deps[i]
		// 将 effectFn 从依赖集合中移除
		deps.delete(effectFn)
	}
	// 最后需要重置 effectFn.deps 数组
	effectFn.deps.length = 0
}

// 避免死循环
function trigger(target, key) {
    const depsMap = bucket.get(target)
    if (!depsMap) return
	const effects = depsMap.get(key)
	// effects && effects.forEach(fn => fn()) 
	// 调用 forEach 遍历 Set 集合时
	// 如果一个值已经被访问过了，但该值被删除并重新添加到集合
	// 如果此时 forEach 遍历没有结束，那么该值会重新被访问
	// cleanup从集合中删除
	// fn()执行又加回集合
	const effectsToRun = new Set(effects) 
    effectsToRun.forEach(effectFn => effectFn())
}

```

## 嵌套的 effect 与 effect 栈
