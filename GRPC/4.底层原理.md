# 底层原理
## RPC流
下面展示了RPC如何通过网络来运行：
![](4.底层原理/Pasted%20image%2020221001162210.png)
运行流程如下：
1. 客户端进程通过生成的代码调用`getProduct`方法
2. 客户端存根创建HTTP POST请求
	- `content-type=application/grpc`
	- 远程方法`/production/getProduct`放在HTTP/2的头中
3. HTTP请求通过网络发送到服务端
4. 服务端接收到消息后，检查消息头信息确定调用的服务方法，传递给服务端骨架
5. 服务端骨架将消息字节解析成特定语言的数据结构
6. 借助解析后的消息，服务发起对`getProduct`方法的本地调用
7. 服务方法的相应经过编码后发回客户端

## protocol buffers
对于下面的消息定义：

```protobuf
message Product {
	string id = 1;
	string name = 2; 
	string description = 3; 
	float price = 4;
}
```

要根据消息定义生成与之对等的字节内容，每个字段包含一个字段标识符及其编码后的值：
![](4.底层原理/Pasted%20image%2020221002141637.png)
### 标签
其中标签由两部分组成
1. 字段索引：消息定义中为每个字段设置的唯一数字
2. 线路类型：字段的数据类型，可以确定值的长度

结构如下：
![](4.底层原理/Pasted%20image%2020221002143908.png)
### 值
`protocol buffers` 使用不同的编码技术来编码不同类型的数据。下面介绍几种常用的编码技术

#### Varint类型
可变长度整数是使用单字节或多字节来序列化整数的方法。这种方法序列化每个整数时只分配足够表示其值的字节数。这样值越小的数字就会使用越少的字节数，可以更紧凑的表示数字。`int32`、`int64`、`uint32`、`uint64`、`sint32`、`sint64`、`bool` 和 `enum` 这样的字段类型会按照 `Varint` 进行编码。

`Varint`表示的整数中，每字节中较低的 7 位用来存储数字的二进制补码形式，最高位有特殊的含义：
- 如果该位为 1 则表示后续的字节也是该数字的一部分
- 如果该位为 0 则结束

#### 有符号整数类型
对于有符号类型，会使用 `zigzag` 编码来将有符号整数转换成无符号整数。随后，无符号整数会使用前面的 `Varint` 编码技术来进行编码。`zigzag`编码会按照之字型的方式映射为无符号整数，例子如下：
![](4.底层原理/Pasted%20image%2020221004091728.png)
#### 非 Varint类型
恰好与 `Varint` 类型相反，他们会分配固定数量的字节，字节数与实际值没有关系。有两种数据类型属于非 `Varint` 类型。其中一个用来表示64位的数据，如`fixed64`、`double`，另一个用来表示32位的数据，如`fixed32`、`float`。

#### 字符串类型
字符串类型属于基于长度分割的数据类型，即首先有一个经过 `Varint` 编码的长度值，然后才是指定数量的字节数据。字符串值会使用UTF-8字符编码格式进行编码。

## 基于长度前缀的消息分帧
消息通信过程中我们通常会使用某种机制将每个消息帧分开，以便于目标受众很容易地提取信息。gRPC使用了名为**长度前缀分帧**的消息分帧技术。

长度前缀分帧是指在写入消息本身之前写入长度信息来表明每条消息的大小，在gRPC中每条消息都有额外的4字节来设置其大小，也就意味着gRPC可以处理大小不超过4GB的所有消息。
![](4.底层原理/Pasted%20image%2020221004214722.png)
当使用`protocol buffers`进行编码时，我们会将消息的定义和消息的值转化成二进制格式的消息，然后计算二进制内容的大小，并以大端格式将其添加到二进制内容的前面。

除了消息的大小，帧中还有单字节的无符号整数，用来表明数据是否进行了压缩。假设压缩标记值为`1`，则代表二进制数据使用 `Message-Encoding` 头信息中声明的机制进行了压缩，该信息会作为 `HTTP` 传输头信息中的一项。假设值为 `0`，则代表消息字节没有进行压缩。

## 基于HTTP/2的gRPC
`HTTP/2`解决了以前版本在安全性、速度方面遇到的问题。gRPC使用`HTTP/2`作为其传输协议来实现通过网络发送消息。

在`HTTP/2`中，客户端和服务器的所有通信都是通过一个TCP连接完成的，这个连接可以传送任意数量的双向字节流。下面是`HTTP/2`的一些术语：
- 流：一个已建立的双向字节流
- 帧：最小的通信单元，每一帧都包含一个帧头，它至少要标记该帧所属的流
- 消息：完整的帧序列，映射为一条逻辑上的HTTP消息，由一帧或多帧组成，一个消息可以分解成帧

gRPC 通道代表一个端到端的连接，也就是一个 `HTTP/2` 连接。当客户端应用程序创建 gRPC 通道的时候，它会在幕后创建一个到服务器端的 `HTTP/2` 连接。在通道创建完成之后，就可以重用它来发送多个到服务器端的远程调用。这些远程调用会映射为 `HTTP/2` 中的流。远程调用中的消息以 `HTTP/2` 帧的形式进行发送，帧可能会携带一条 gRPC 长度前缀的消息，也可能在 gRPC 消息非常大的情况下，一条消息跨多帧。
![](4.底层原理/Pasted%20image%2020221004221649.png)
当把消息以请求消息或响应消息的形式通过网络进行发送时，除了消息本身，还要发送额外的头信息。

### 请求信息
请求信息用于初始化远程调用，始终由客户端应用程序来触发。它包含三部分：
1. 请求头信息
2. 以长度作为前缀的消息
3. 流结束标记`EOS`

以 `ProductInfo` 服务中的 `getProduct` 方法为例：
```properties
HEADERS (flags = END_HEADERS) 
# 以 : 开头的头信息叫作保留头信息，HTTP/2要求保留头信息出现在其他头信息之前。
:method = POST                            # 定义HTTP方法，gRPC都为POST
:scheme = http                            # 定义HTTP模式，或者为HTTPS
:path = /ProductInfo/getProduct           # 端点路径：/{服务名}/{方法名}
:authority = abc.com                      # 目标URI的虚拟主机名
te = trailers                             # 不兼容代理的检测，gRPC中必须为trailers
grpc-timeout = 1S                         # 调用的超时时间
content-type = application/grpc           
grpc-encoding = gzip                      # 压缩类型
# 声明自定义元数据时，需要确保不以 grpc- 开头
authorization = Bearer xxxxxx             # 可选的元数据
```

请求消息的结束通过在最后一个 `DATA` 帧上添加 `END_STREAM` 标记来实现。当因为没有要发送的数据而需要关闭请求流时，必须发送一个带有 `END_STREAM` 标记的空数据帧:
```properties
DATA (flags = END_STREAM)
<Length-Prefixed Message>
```

### 响应消息
响应消息由服务器端生成，用来响应客户端的请求。与请求消息类似，响应消息也包含 3 个主要部分：
1. 响应头信息
2. 以长度作为前缀的消息(当有消息需要响应时)
3. `trailer`

以 `ProductInfo` 服务中的 `getProduct` 方法为例：
```properties
HEADERS (flags = END_HEADERS) 
:status = 200                    # 表明HTTP请求的状态
grpc-encoding = gzip 
content-type = application/grpc
```

`END_STREAM` 标记并不会随数据帧一起发送，而会作为单独的头信息来发送，名为 `trailer`:
```properties
DATA
<Length-Prefixed Message>
```

最后，通过发送 `trailer` 来提醒客户端响应消息已发送。`trailer` 会携带状态码以及请求的状态信息
```properties
HEADERS (flags = END_STREAM, END_HEADERS) 
grpc-status = 0                  # 定义gRPC状态码
grpc-message = xxxx              # 定义对错误的描述。只有出现错误时，才会进行设置
```

有时请求调用可能会立即失败。这时服务器端需要发回一个不包含数据帧的响应。因为服务器端只发送 `trailer` 作为响应，所以这些 `trailer` 也会以 `HTTP/2` 头信息帧的形式进行投递，同时会包含 `END_STREAM` 标记。另外，trailer 会包含下面的头信息：
- HTTP 状态：`:status`
- 内容类型：`content-type `
- 状态：`grpc-status`
- 状态信息：`grpc-message`

### 理解 gRPC 通信模式中的消息流
#### 一元 RPC 模式
客户端消息最后会添加一个EOS标记，方便客户端半关连接，并标记请求消息的结束。
![](4.底层原理/Pasted%20image%2020221004225343.png)
#### 服务器端流 RPC 模式
服务器端不再向客户端发送一条响应消息，而会发送多条响应消息。服务器端会持续等待， 直到接收到完整的请求消息，随后它会发送响应头消息和多条以长度作为前缀的消息。在服务器端发送带有状态详情的 `trailer` 头信息之后，通信就会关闭。
![](4.底层原理/Pasted%20image%2020221004225449.png)
#### 客户端流 RPC 模式
客户端向服务器端发送多条消息，服务器端在响应时发送一条消息。客户端首先通过发送头信息帧来与服务器端建立连接，然后以数据帧的形式，向服务器端发送多条以长度作为前缀的消息。最后，通过在末尾的数据帧中发送 `EOS` 标记，客户端将连接设置为半关的状态。与此同时，服务器端读取所接收到的来自客户端的消息。在接收到所有的消息之后，客户端发送一条响应消息和 `trailer` 头信息，并关闭连接。
![](4.底层原理/Pasted%20image%2020221004225615.png)
#### 双向流 RPC 模式
客户端通过发送头信息帧与服务器端建立连接。然后，它们会互发 以长度作为前缀的消息，无须等待对方结束。
![](4.底层原理/Pasted%20image%2020221004225745.png)
## gRPC实现架构
![](4.底层原理/Pasted%20image%2020221004225812.png)
