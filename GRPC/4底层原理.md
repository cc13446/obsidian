# 底层原理
## RPC流
下面展示了RPC如何通过网络来运行：
![](4.底层原理/Pasted%20image%2020221001162210.png)
运行流程如下：
1. 客户端进程通过生成的代码调用`getProduct`方法
2. 客户端存根创建HTTP POST请求
	- `content-type=application/grpc`
	- 远程方法`/production/getProduct`放在HTTP/2的头中
3. HTTP请求通过网络发送到服务端
4. 服务端接收到消息后，检查消息头信息确定调用的服务方法，传递给服务端骨架
5. 服务端骨架将消息字节解析成特定语言的数据结构
6. 借助解析后的消息，服务发起对`getProduct`方法的本地调用
7. 服务方法的相应经过编码后发回客户端

## protocol buffers
对于下面的消息定义：

```protobuf
message Product {
	string id = 1;
	string name = 2; 
	string description = 3; 
	float price = 4;
}
```

要根据消息定义生成与之对等的字节内容，每个字段包含一个字段标识符及其编码后的值：
![](4.底层原理/Pasted%20image%2020221002141637.png)
### 标签
其中标签由两部分组成
1. 字段索引：消息定义中为每个字段设置的唯一数字
2. 线路类型：字段的数据类型，可以确定值的长度

结构如下：
![](4.底层原理/Pasted%20image%2020221002143908.png)
### 值
`protocol buffers` 使用不同的编码技术来编码不同类型的数据。下面介绍几种常用的编码技术

#### Varint类型
可变长度整数是使用单字节或多字节来序列化整数的方法。这种方法序列化每个整数时只分配足够表示其值的字节数。这样值越小的数字就会使用越少的字节数，可以更紧凑的表示数字。`int32`、`int64`、`uint32`、`uint64`、`sint32`、`sint64`、`bool` 和 `enum` 这样的字段类型会按照 `Varint` 进行编码。

`Varint`表示的整数中，每字节中较低的 7 位用来存储数字的二进制补码形式，最高位有特殊的含义：
- 如果该位为 1 则表示后续的字节也是该数字的一部分
- 如果该位为 0，则结束

#### 有符号整数类型
对于有符号类型，会使用 `zigzag` 编码来将有符号整数转换成无符号整数。随后，无符号整数会使用前面的 `Varint` 编码技术来进行编码。



