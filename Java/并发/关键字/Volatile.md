转载自`https://pdai.tech/`
# 作用
### 防重排序
在并发环境下的单例实现方式，我们通常可以采用双重检查加锁的方式来实现

```java
public class Singleton {
    public static volatile Singleton singleton;
    private Singleton() {};
    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```
分析一下为什么要在变量`singleton`之间加上`volatile`关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：
1. 分配内存空间
2. 初始化对象。
3. 将内存空间的地址赋值给对应的引用

但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：
1. 分配内存空间
2. 将内存空间的地址赋值给对应的引用
3. 初始化对象

如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为`volatile`类型的变量。

### 实现可见性
可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区：线程工作内存。`volatile`关键字能有效的解决这个问题。

### 保证原子性:单次读/写
`volatile`不能保证完全的原子性，只能保证单次的读/写操作具有原子性。

共享的`long`和`double`变量的为什么要用`volatile`?

因为`long`和`double`两种数据类型的操作可分为高32位和低32位两部分，因此普通的`long`或`double`类型读/写可能不是原子的。因此，鼓励大家将共享的`long`和`double`变量设置为`volatile`类型，这样能保证任何情况下对`long`和`double`的单次读/写操作都具有原子性。

# 实现原理
### Lock指令
在 `volatile` 修饰的共享变量进行写操作的时候，字节码会多出 `lock` 前缀的指令，在多核处理器下会引发两件事情:
1. 将当前处理器缓存行的数据写回到系统内存
2. 写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效

为了保证各个处理器的缓存是一致的，实现了缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里，即可以获取当前最新值。

这里可以参见：MESI 协议

### 有了MESI为什么还要Volatile？
既然`CPU`有了`MESI`协议可以保证`cache`的一致性，那么为什么还需要`volatile`这个关键词来保证可见性？或者是只有加了`volatile`的变量在多核`cpu`执行的时候才会触发缓存一致性协议？

两个解释结论：
1. 多核情况下，所有的cpu操作都会涉及缓存一致性的校验，只不过该协议是弱一致性，不能保证一个线程修改变量后，其他线程立马可见，也就是说虽然其他CPU状态已经置为无效，但是当前**CPU可能将数据修改之后又去做其他事情，没有来得及将修改后的变量刷新回主存**，而如果此时其他CPU需要使用该变量，则又会从主存中读取到旧的值。**而volatile则可以保证可见性，即立即刷新回主存**，修改操作和写回操作必须是一个原子操作；
2. 正常情况下，系统操作并不会进行缓存一致性的校验，只有变量被volatile修饰了，该变量所在的缓存行才被赋予缓存一致性的校验功能。

### 内存屏障
`volatile` 变量的内存可见性是基于内存屏障(Memory Barrier)实现
-  内存屏障，又称内存栅栏，是一个 CPU 指令
-  插入特定类型的内存屏障可以禁止特定类型的编译器重排序和处理器重排序

在《JAVA并发编程的艺术》中有这样一张表：

| 是否能重排序 |           | 第二个操作  |             |
|:------------:|:---------:|:-----------:|:-----------:|
|  第一个操作  | 普通读/写 | volatile 读 | volatile 写 |
|  普通读/写   |           |             |     NO      |
| volatile 读  |    NO     |     NO      |     NO      |
| volatile 写  |           |     NO      |     NO      |


可以总结为三条：
1. 当第二个操作是 `volatile` 写时，不管第一个操作是什么，都不能重排序
2. 当第一个操作是 `volatile` 读时，不管第二个操作是什么，都不能重排序。
3. 当第一个操作是 `volatile` 写，第二个操作是 `volatile` 读时，不能重排序

第三条是显而易见的，那么想要理解第一、二条需要了解 `volatile` 的一些原理和内存模型。

#### 内存模型
为了提高处理速度，处理器不会直接和主存进行通信，而是先将系统内存的数据读取到内部缓存中后再进行操作，但操作完不知道何时会写到内存。`JMM`定义了线程和主内存之间的关系：线程之间的共享变量存储在主存中，每个线程都有一个私有的本地内存，本地内存中存储了共享内存的副本。

#### 第一条规律
当第二个操作是`volatile`写时，不管第一个操作是什么，都不能重排序。

如果进行重排序，那么 `volatile` 写会使其他CPU的缓存行无效，就不能保证 `volatile` 写之前的共享变量数据的一致，如此就违背了内存语义。

#### 第二条规律
当第一个操作是 `volatile` 读时，不管第二个操作是什么，都不能重排序。

如果进行重排序，读之后缓存行的数据就会被置为无效，那么缓存行中的普通共享变量也会再从主存中重新读取，提前的操作读到的可能是无效的缓存，如此就违背了内存语义。

