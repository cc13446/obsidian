#  并发三要素
- 可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到
- 原子性：一个操作或者多个操作要么全部执行并且过程中不会被打断，要么就都不执行
- 有序性：即程序执行的顺序按照代码的先后顺序执行

## 重排序的三种类型
1. 编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句执行顺序
2.  指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

## Java 处理三要素
1. 原子性：对基本数据类型的变量的读取和赋值操作是原子性操作
2. 可见性：volatile关键字来保证可见性
3. 有序性：通过Happens-Before 规则来保证有序性

# Happens-Before 规则
1. 单一线程原则：在一个线程内，在程序前面的操作先行发生于后面的操作
2. 管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作
3. `volatile` 变量规则：对一个 `volatile` 变量的写操作先行发生于后面对这个变量的读操作
4. 线程启动规则：`Thread` 对象的 `start()` 方法调用先行发生于此线程的每一个动作
5. 线程加入规则：`Thread` 对象的结束先行发生于 `join()`方法返回
6. 线程中断规则：对线程`interrupt()` 方法的调用先行发生于被中断线程的代码检测到中断事件的发生
7. 对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的 `finalize()` 方法的开始。
8. 传递性

# 线程安全级别
## 1. 不可变
不可变的类型
1. final 关键字修饰的基本数据类型
2. String
3. 枚举类型
4. Number 部分子类
	- 如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型
	- 但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。
5. `Collections.unmodifiableXXX()`方法修饰的集合

## 2.  绝对线程安全
不管运行时环境如何，调用者都不需要任何额外的同步措施。

## 3. 相对线程安全
相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。 在 Java 语言中，大部分的线程安全类都属于这种类型，例如 `Vector`、`ConcurrentHashTable`、`synchronizedCollection()` 方法包装的集合等。

## 4. 线程兼容
线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。

## 5. 线程对立
线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。

# 不需要线程同步的方案
1. 栈封闭：栈中的变量为线程私有。
2. 线程本地存储：`ThreadLocal threadLocal = new ThreadLocal();`
3. 可冲入代码：个人理解为不保存状态的代码