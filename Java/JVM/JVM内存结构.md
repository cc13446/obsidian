
转载自`https://pdai.tech/`
# JVM 内存结构

![[Pasted image 20220504221135.png]]

内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。

下图是 JVM 整体架构，中间部分就是 Java 虚拟机定义的各种运行时数据区域

![[Pasted image 20220505100141.png]]

Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。
-   **线程私有**：程序计数器、虚拟机栈、本地方法区
-   **线程共享**：堆、方法区, 堆外内存（Java7的永久代或JDK8的元空间、代码缓存）

## 程序计数器
- 它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域
- 在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致
- 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
-   **它是唯一一个在 JVM 规范中没有规定任何 `OutOfMemoryError` 情况的区域**


## 虚拟机栈

### 概述

Java 虚拟机栈(Java Virtual Machine Stacks)，早期也叫 Java 栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。

### 作用
主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。

### 特点
-   栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
-   JVM 直接对虚拟机栈的操作只有两个：每个方法执行入栈，方法执行结束出栈
-   栈不存在垃圾回收问题

### 异常

Java 虚拟机规范允许 **Java虚拟机栈的大小是动态的或者是固定不变的**

-  如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 `StackOverflowError` 异常
-   如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那将会抛出 `OutOfMemoryError` 异常

可以通过参数`-Xss`来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。

### 栈的存储单位

栈中存储什么？
-   每个线程都有自己的栈，栈中的数据都是以栈帧`Stack Frame`的格式存在
-   在这个线程上正在执行的每个方法都各自有对应的一个栈帧
-   栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息


每个栈帧`Stack Frame`中存储着：
-   局部变量表`Local Variables`
-   操作数栈`Operand Stack`(或称为表达式栈)
-   动态链接`Dynamic Linking`：指向运行时常量池的方法引用
-   方法返回地址`Return Address`：方法正常退出或异常退出的地址
-   一些附加信息

![[Pasted image 20220505101936.png]]

#### 动态链接（指向运行时常量池的方法引用）
-   **每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用**。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。
-   在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在 Class 文件的常量池中。一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**

![[Pasted image 20220505102426.png]]

##### JVM 是如何执行方法调用的

方法调用不同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本，暂时还不涉及方法内部的具体运行过程。Class 文件的编译过程中不包括传统编译器中的连接步骤，一切方法调用在 Class文件里面存储的都是**符号引用**，而不是方法在实际运行时内存布局中的入口地址**直接引用**。也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。

在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关
-   **静态链接**：当一个字节码文件被装载进 JVM 内部时，如果被调用的**目标方法在编译期可知**，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接
-   **动态链接**：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接

对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。**绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次**。

-   早期绑定：**早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时**，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。
-   晚期绑定：如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式就被称为晚期绑定。

##### 虚方法和非虚方法

-   如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法
-   其他方法称为虚方法

##### 虚方法表

在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标有可能会影响到执行效率。为了提高性能，JVM 采用在类的方法区建立一个虚方法表（virtual method table），使用索引表来代替查找。非虚方法不会出现在表中。

每个类中都有一个虚方法表，表中存放着各个方法的实际入口。虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。


## 本地方法栈

### 本地方法接口

简单的讲，一个 `Native Method` 就是一个 Java 调用非 Java 代码的接口。我们知道的 Unsafe 类就有很多本地方法。

Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来也不容易，或者我们对程序的效率很在意时，问题就来了
1. 与 Java 环境外交互：有时 Java 应用需要与外面的环境交互，这就是本地方法存在的原因。
2. 与操作系统交互：JVM 支持 Java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持。通过本地方法，我们可以实现用 Java 与实现了 jre 的底层系统交互。


### 本地方法栈（Native Method Stack）
1. Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用
2. 本地方法栈也是线程私有的
3. 允许线程固定或者可动态扩展的内存大小
4. 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 `StackOverflowError` 异常
5.  如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java虚拟机将会抛出一个`OutofMemoryError`异常
6. 本地方法是使用 C 语言实现的
7. 它的具体做法是 `Native Method Stack` 中登记 native 方法，在 `Execution Engine` 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。
8. 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存
9. 并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈
10. 在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一

## 堆内存

### 内存划分

对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。

为了进行高效的垃圾回收，虚拟机把堆内存逻辑上划分成三块区域`唯一理由就是优化 GC`：
1.  新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代
2. 老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大
3. 元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等
	- JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存

Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 `-Xmx` 和 `-Xms` 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 `OutOfMemoryError` 异常。

####  年轻代 (Young Generation)

年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。称为 **Minor GC**。

年轻一代被分为三个部分
- 伊甸园`Eden Memory`
- 两个幸存区`Survivor Memory`
- 默认比例是`8:1:1`

特点
-   大多数新创建的对象都位于 Eden 内存空间中
-   当 Eden 空间被对象填充时，执行Minor GC将所有幸存者对象移动到一个幸存者空间中
-   Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。有一个幸存者空间总是空的
-   经过多次 GC 循环后存活下来的对象被移动到老年代。

#### 老年代(Old Generation)

旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为`Major GC`，通常需要更长的时间。

大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝

![[Pasted image 20220505103733.png]]

####  元空间

不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。

### 对象的分配过程

为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。
1.  `new` 的对象先放在伊甸园区，此区有大小限制
2.  当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区
3.  然后将伊甸园中的剩余对象移动到幸存者 0 区
4.  如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区
5.  如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区
6.  什么时候才会去养老区呢？ 默认是 15 次回收标记
7.  在养老区，相对悠闲。当养老区内存不足时，再次触发 `Major GC`，进行养老区的内存清理
8.  若养老区执行了 `Major GC` 之后发现依然无法进行对象的保存，就会产生 OOM 异常

### TLAB（Thread Local Allocation Buffer）
从内存模型而不是垃圾回收的角度，对 `Eden` 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内。多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为快速分配策。OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计

####  为什么要有 TLAB ?
堆区是线程共享的，任何线程都可以访问到堆区中的共享数据。由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。

### 堆是分配对象存储的唯一选择吗

> 随着 JIT 编译期的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。 ——《深入理解 Java 虚拟机》

####  逃逸分析

逃逸分析`Escape Analysis`是目前 Java 虚拟机中比较前沿的优化技术。这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

逃逸分析的基本行为就是分析对象动态作用域：

-   当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
-   当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。

使用逃逸分析，编译器可以对代码做优化：

-   **栈上分配**：将堆分配转化为栈分配。
-   **同步省略**：如果一个对象被发现只能从一个线程被访问到，那么可以不考虑同步(锁消除)
-   **分离对象或标量替换**：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分或全部可以不存储在内存，而存储在 CPU 寄存器

## 方法区
方法区`Method Area`与 Java 堆一样，是所有线程共享的内存区域。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 `Non-Heap`，目的应该是与 Java 堆区分开。运行时常量池是方法区的一部分。`Class` 文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 `String.intern()`方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 `OutOfMemoryError` 异常。
-   方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误
-   JVM 关闭后方法区即被释放

方法区`method area` 只是JVM 规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而永久代`PermGen`是`Hotspot`虚拟机特有的概念， Java8 的时候又被`元空间`取代了，永久代和元空间都可以理解为方法区的落地实现。

永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理）不受 JVM 限制，也比较难发生OOM（都会有溢出异常）

所以对于方法区，Java8 之后的变化：
-   移除了永久代`PermGen`，替换为元空间`Metaspace`；
-   永久代中的 `class metadata` 转移到了 `native memory`（本地内存，而不是虚拟机）
-   永久代中的 `interned Strings` 和 `class static variables` 转移到了`Java heap`
-   永久代参数 `PermSize MaxPermSize` 变元空间参数`MetaspaceSize MaxMetaspaceSize`

### 方法区内部结构

方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。

#### 类型信息

对每个加载的类型，JVM 必须在方法区中存储以下类型信息
-   这个类型的完整有效名称（全名=包名.类名）
-   这个类型直接父类的完整有效名（对于 interface或是 java.lang.Object，都没有父类）
-   这个类型的修饰符（public，abstract，final 的某个子集）
-   这个类型直接接口的一个有序列表

#### 域`Field`信息
-   JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序
-   域的相关信息包括：域名称、域类型、域修饰符

#### 法`Method`信息

JVM 必须保存所有方法的
-   方法名称
-   方法的返回类型
-   方法参数的数量和类型
-   方法的修饰符
-   方法的字符码、操作数栈、局部变量表及大小（abstract 和 native 方法除外）
-   异常表 除 `abstract` 和 `native` 方法外
    -  每个异常处理的开始位置、结束位置
    -  代码处理在程序计数器中的偏移地址
    -  被捕获的异常类的常量池索引

### 栈、堆、方法区的交互关系

![[Pasted image 20220505111214.png]]

### 运行时常量池

运行时常量池是方法区的一部分，理解运行时常量池的话，我们先来说说字节码文件中的常量池

####  常量池

一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表，包含各种字面量和对类型、域和方法的符号引用。

##### 为什么需要常量池？

一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。

常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。

#### 运行时常量池
1. 在加载类和结构到虚拟机后，就会创建对应的运行时常量池
2. 常量池表是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，
	- 这部分内容将在类加载后存放到方法区的运行时常量池中
3. JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的
4. 运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址
5. 运行时常量池，相对于 Class 文件常量池的另一个重要特征是：动态性，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中
6. 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 `OutOfMemoryError` 异常。

### 方法区在 JDK6、7、8中的演进细节

只有 HotSpot 才有永久代的概念

1. `jdk1.6及之前`：有永久代，静态变量存放在永久代上

2. `jdk1.7`：有永久代，但已经逐步去永久代，字符串常量池、静态变量移除，保存在堆中

3. `jdk1.8 及之后`：取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中

### 5.6 方法区的垃圾回收

方法区的垃圾收集主要回收两部分内容：**常量池中废弃的常量和不再使用的类型**。

先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：
-   类和接口的全限定名
-   字段的名称和描述符
-   方法的名称和描述符

HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收

判定一个类型是否属于不再被使用的类，需要同时满足三个条件：

-   该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例
-   加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成
-   该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

Java 虚拟机被允许堆满足上述三个条件的无用类进行回收，这里说的仅仅是被允许，而并不是和对象一样，不使用了就必然会回收。在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。
