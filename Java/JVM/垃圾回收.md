转载自`https://pdai.tech`
# 判断回收
## 引用计数法
给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。

两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。

## 可达性分析算法
通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。

![[Pasted image 20220505114545.png]]

在 Java 中 GC Roots 一般包含以下内容:
-   虚拟机栈中引用的对象
-   本地方法栈中引用的对象
-   方法区中类静态属性引用的对象
-   方法区中的常量引用的对象

# 引用类型

无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。

Java 具有四种强度不同的引用类型。

## 强引用
被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。

```java
Object obj = new Object();
```
## 软引用

被软引用关联的对象只有在内存不够的情况下才会被回收。

使用 `SoftReference` 类来创建软引用。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

## 弱引用

被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。

使用 `WeakReference` 类来实现弱引用。

```
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

## 虚引用

又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。

使用 `PhantomReference` 来实现虚引用。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj = null;
```

# 垃圾回收算法
## 标记 - 清除
![[Pasted image 20220505114911.png]]

将存活的对象进行标记，然后清理掉未被标记的对象。

不足:
-   标记和清除过程效率都不高；
-   会产生大量不连续的内存碎片，导致无法给大对象分配内存。

## 标记 - 整理

![[Pasted image 20220505114935.png]]

让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

## 复制

![[Pasted image 20220505114954.png]]

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是只使用了内存的一半。

现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 `Eden` 空间和两块较小的 `Survivor` 空间，每次使用 `Eden` 空间和其中一块 `Survivor`。在回收时，将 `Eden` 和 `Survivor` 中还存活着的对象一次性复制到另一块 `Survivor` 空间上，最后清理 `Eden` 和使用过的那一块 `Survivor`。

`HotSpot` 虚拟机的 `Eden` 和 `Survivor` 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 `Survivor` 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。

## 分代收集

现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

一般将堆分为新生代和老年代。
-   新生代使用: 复制算法
-   老年代使用: 标记 - 清除 或者 标记 - 整理 算法