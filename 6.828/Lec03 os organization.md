## xv6 Book

### 抽象物理资源 
为了实现进程之间的强隔离，禁止应用程序直接访问敏感的硬件资源，需要将硬件资源抽象为服务，比如用文件系统抽象磁盘资源。这样就可以分时复用cpu、更方便的管理内存和磁盘等。

### 机器模式、监督者模式和用户模式
进程和操作系统之间应该有一个分界线，如果进程发生错误，我们不希望操作系统或者其他的进程崩溃。操作系统应该可以清理崩溃的应用程序并继续运行其他的应用程序。

CPU提供了强隔离的硬件支持。`RISC-V`有三种模式，机器模式、监督者模式和用户模式。在机器模式下执行的指令具有完全的权限，一个CPU在机器模式下启动。机器模式主要用于配置计算机。`xv6`会在机器模式下执行几条指令，然后转为监督者模式。

普通进程只能运行用户模式的指令，被称为运行在用户空间，而处于监督者模式的软件可以执行特权指令，被称为运行在内核空间。

一个应用程序如果要调用内核函数，必须过渡到内核。CPU提供了一个特殊的指令，可以将CPU从用户模式切换到监督者模式，并在内核指定的入口处进入内核，比如`RISC-V`的`ecall`指令。一旦CPU切换到监督者模式，内核需要验证系统调用的参数，决定是否允许应用程序执行请求的操作，然后拒绝或执行该操作。

### 内核组织
宏内核：整个操作系统驻留在内核中，所有系统调用的实现都在监督者模式下运行
微内核：尽量减少在监督者模式下运行的操作系统代码量，而在用户模式下执行操作系统的大部分代码

### 进程概述
xv6 使用页表为每个进程提供其独有的地址空间，页表将虚拟地址映射为物理地址。

每个进程的地址空间从高到低分为以下几个区域:
- `trampoline`
- `trapframe`
- 堆
- 用户栈
- 全局变量

xv6使用结构体`proc`维护一个进程的状态：
- 用户栈
- 内核栈
- 运行状态
- 页表

当进程使用系统调用时，处理器转入内核栈中，提升硬件的特权级，然后运行系统调用对应的内核代码。当系统调用完成时，又降低硬件特权级从内核空间回到用户空间，转入用户栈，恢复执行系统调用指令后面的那条用户指令。进程的线程交替地使用着用户栈和内核栈。要注意内核栈是用户代码无法使用的，这样即使一个进程破坏了自己的用户栈，内核也能保持运行。

### 启动内核
计算机开机时，运行存储在ROM中的`boot loader`，将xv6内核加载到内存中。然后，在机器模式下，CPU从 `_entry`开始执行xv6。此时禁用了分页硬件，因此虚拟地址直接映射到物理地址。

`boot loader`将xv6内核加载到物理地址`0x80000000`的内存中。之所以将内核放在`0x80000000`而不是`0x0`，是因为地址范围`0x0:0x80000000`包含I/O设备。

`_entry`为C代码的运行指定栈，这个栈`stack0`在`start.c`中声明，`_entry`将`stack0`的栈顶加载到`sp`，然后跳转到`start`函数。
```bash
# qemu -kernel loads the kernel at 0x80000000  
# and causes each CPU to jump there.  
# kernel.ld causes the following code to  
# be placed at 0x80000000.  
.section .text  
_entry:  
		# set up a stack for C.  
        # stack0 is declared in start.c,  
        # with a 4096-byte stack per CPU.  
        # sp = stack0 + (hartid * 4096)  
        la sp, stack0  
        li a0, 1024*4  
		csrr a1, mhartid  
        addi a1, a1, 1  
        mul a0, a0, a1  
        add sp, sp, a0  
		# jump to start() in start.c  
        call start  
spin:  
        j spin
```

`start`做了一些只能在机器模式下做的配置，并初始化计时器中断。然后通过`mret`指令切换到监督者模式，这条指令用于从监督者模式到机器模式的调用返回，因此`start`将之前的特权模式设置为监督者模式，然后将`main`函数设置为返回地址，这样假装从机器模式返回到监督者模式。

`main`函数在监督者模式下运行，初始化了一些设备和子系统，并调用`userinit`创建了第一个进程。

第一个进程执行了汇编编写的小程序`initcode.S`，通过`exec`系统调用重新进入内核，并用`/init`替换当前进程的内存和寄存器。一旦内核完成`exec`，它就会在`/init`进程中返回到用户空间。

`/init`进程创建一个新的控制台设备文件，然后以文件描述符0、1和2的形式打开它。然后无限循环的启动一个shell并处理僵尸进程。这样系统就启动了。

## class

### 操作系统隔离性

