##  xv6 book
页表帮助操作系统为每个进程提供各自私有的地址空间和内存。页表决定了内存地址的含义，以及那些物理地址可以被访问。还可以利用页表在几个地址空间中映射同一内存`trampoline`，以及用一个未映射页来保护内核栈和用户栈。

### 分页硬件
两个缩写：
- `PTE`：Page Table Entry
- `PPN`：Physical Page Number

`RISC-V`指令操作的是虚拟地址，而机器的物理内存使用物理地址做索引。RISC-V的页表硬件通过将每个虚拟地址映射到一个物理地址将这两种地址联系起来。

xv6只使用64位虚拟地址的低39位，一个页表在逻辑上是一个由2的27次幂个页表项`PTE`组成的数组。每个`PTE`包含一个44位的物理页号`PPN`和一些标志位。

分页硬件通过利用39位中的高27位索引到页表中找到一个PTE来映射一个虚拟地址，并计算出一个56位的物理地址，它的前44位来自于PTE中的PPN，而它的后12位则是从原来的虚拟地址复制过来的。xv6的页大小为4096字节。

实际上xv6使用了多级页表，页表以三层树的形式存储在物理内存中，树的根部是一个`4096`字节的页表页，它包含`512`个PTE，这些PTE包含树的下一级页表页的物理地址。每一页都包含`512`个PTE，用于指向下一个页表或物理地址。分页硬件用27位中的高9位选择根页表页中的PTE，用中间9位选择树中下一级页表页中的PTE，用低9位选择最后的PTE。

如果在进行地址转化的时候某个PTE不存在，分页硬件就会触发一个缺页异常，让内核来处理。这样就允许三层结构忽略那些没有被映射的页表了。

每个PTE有一些标志位
- `PTE_V`：PTE 是否存在
- `PTE_R`：是否允许指令读取该页
- `PTE_W`：是否允许指令向该页写入
- `PTE_X`：CPU 是否可以将页面的内容解释为指令并执行
- `PTE_U`：是否允许用户态下的指令访问页面

内核必须将根页表的物理地址写入`satp`寄存器中，一个CPU将使用自己的`satp`所指向的页表来映射后续指令产生的所有地址。每个CPU都有自己的`satp`，这样不同的CPU可以运行不同的进程，每个进程都有自己的页表所描述的私有地址空间。

### 内核地址空间
xv6为每个进程维护一个用于描述进程的用户地址空间的页表，外加一个单独的描述内核地址空间的页表。通过内核地址空间的映射，进程能够通过可预测的虚拟地址访问物理内存和各种硬件资源。

![](Lec04%20page%20tables/Pasted%20image%2020230423151906.png)

从物理地址 `0x80000000` 开始，至少到 `0x86400000`，xv6 称之为 `PHYSTOP`，为计算机的物理内存。

QEMU 将设备接口的控制寄存器作为内存映射来暴露给软件，这些映射位于物理地址空间的 `0x80000000` 以下。内核可以通过读写这些特殊的物理地址与设备进行交互，这种读取和写入与设备硬件而不是与RAM进行通信。

物理地址的结构完全由硬件设计者决定，比如操作系统启动时会从地址 `0x80000000` 开始启动，或者某个IO设备接口的寄存器映射在某个特殊的物理地址。

内核对RAM和内存映射的设备寄存器使用**直接映射**，也就是将这些资源映射到和它们物理地址相同的虚拟地址上。例如，内核本身在虚拟地址空间和物理内存中的位置都是`KERNBASE=0x80000000`。直接映射简化了读写物理内存的内核代码。

有一些内核虚拟地址用的不是直接映射：
- `trampoline` 页被映射在虚拟地址空间的顶端，用户页表也有这个映射
- 内核栈页：每个进程都有自己的内核栈，被映射到高地址处

### 创建地址空间代码解析
大部分用于操作地址空间和页表的 xv6 代码都在`kernel/vm.c`中。

核心数据结构是`pagetable_t`：一个指向根页表页的指针，可以是内核页表，也可以是进程页表。

核心函数如下所示，其中以 `kvm` 开头的函数操作内核页表，以 `uvm` 开头的函数操作用户页表，其他函数同时用于这两种页表：
- `kvminit`：创建内核页表
- `kvminithart`：通过将内核根页表页的物理地址写入寄存器 `satp` 中来映射内核页表
- `procinit`：为每个进程分配一个内核栈
- `mappages`：将指定范围的虚拟地址映射到一段物理地址，在页表中记录映射关系
- `walk`：模仿分页硬件查找虚拟地址的 PTE
- `copyout`：将数据复制到用户虚拟地址
- `copyin`：将数据复制出用户虚拟地址

每个 CPU 都会在TLB中缓存页表项，当 xv6 改变页表时，必须告诉 CPU 使相应的缓存 TLB 项无效。

### 物理地址分配
内核必须在运行时为页表、用户内存、内核堆栈和管道缓冲区分配和释放物理内存。xv6 使用内核地址结束到 `PHYSTOP` 之间的物理内存来进行运行时分配。它每次分配和释放整个4096字节的页。通过保存空闲页链表，来记录哪些页是空闲的。分配时从空闲页链表中删除一页，释放时将释放的页面添加到空闲页链表中。

### 物理地址分配代码解析
分配器在 `kalloc.c` 中。分配器的数据结构是一个可供分配的物理内存页的**空闲链表**，每个空闲页的链表元素是一个结构体 `struct run`。分配器把每个空闲页的 `run` 结构体存储在空闲页自身里面，空闲链表由一个**自旋锁**保护。

核心函数如下：
- `kinit`：初始化分配器，包括初始化空闲页链表，保存内核地址结束到 `PHYSTOP` 之间的每一页
- `freerange`：添加内存到空闲页链表，使用 `PGROUNDUP` 来进行地址对齐，对每一页都调用 `kfree`
- `kfree`：释放内存，并将每个字节设置为1，然后将页面预存入释放列表

### 进程地址空间
每个进程都有单独的页表，当 xv6 在进程间切换时，也会改变页表。一个进程的用户内存从虚拟地址 `0` 开始，可以增长到 `MAXVA`，原则上允许一个进程寻址 256GB 的内存。

![](Lec04%20page%20tables/Pasted%20image%2020230423160948.png)

上图更详细地显示了 xv6 中执行进程的用户内存布局。栈只有一页，图中显示的是由 `exec` 创建的初始内容。位于栈顶部的字符串中包含了命令行中输入的参数和指向他们的指针数组。在下方是程序在 `main` 启动的值，就像函数 `main(argc, argv)` 是刚刚被调用一样。

为了检测用户栈溢出分配的栈内存，xv6 会在 `stack` 的下方放置一个无效的保护页。如果用户栈溢出，而进程试图使用栈下面的地址，硬件会因为该映射无效而产生一个缺页异常。

## class
### 地址空间
通过给每个进程一个单独的地址空间来实现隔离性。

虚拟内存可以比物理内存更大，物理内存也可以比虚拟内存更大，可以通过页表灵活实现。

### 页表
每个应用程序都有自己独立的表单，并且这个表单定义了应用程序的地址空间。所以当操作系统将CPU从一个应用程序切换到另一个应用程序时，同时也需要切换SATP寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应表单。

当处理器第一次查找一个虚拟地址时，硬件通过3级页表得到最终的PPN，TLB会保存虚拟地址到物理地址的映射关系。这样下一次访问同一个虚拟地址时，处理器可以查看TLB，TLB会直接返回物理地址，而不需要通过页表得到结果。

如果切换了页表，操作系统需要告诉处理器当前正在切换页表，处理器会清空TLB。因为本质上来说，如果切换了页表，TLB中的缓存将不再有用，所以需要被清空，否则地址翻译可能会出错。

### 内核页表

#### 物理地址
物理地址的结构完全由硬件设计者决定。

#### 虚拟地址
大部分虚拟地址到物理地址的映射都是相等的关系。

内核栈被映射了两次，在靠后的虚拟地址映射了一次，在`PHYSTOP`下的`Kernel data`中又映射了一次，但是实际使用的时候用的是上面的部分，因为有`Guard page`会更加安全。

如果内核栈耗尽了，它会溢出到`Guard page`，但是因为`Guard page`的`PTE`中`Valid`标志位未设置，会导致立即触发`page fault`，这样就知道内核栈出错了。但是也又不想浪费物理内存给`Guard page`，所以`Guard page`不会映射到任何物理内存，它只是占据了虚拟地址空间的一段靠后的地址。


