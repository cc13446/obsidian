# 前端编译与优化
几种编译器：
1. 前端编译器：java转变为class文件的过程。`javac`
2. 即时编译器：字节码转变为本地机器码。`Graal`
3. 提前编译器：直接把程序编译成与目标机器指令集相关的二进制代码的过程。`Jaotc`

本文指的是第一种，这类前端编译器对于代码的运行效率几乎没有任何优化措施。性能的全部优化都在即时编译器里面，这样可以让那些不是`Javac`产生的Class文件也能享受到编译器的优化。但是它确实做了很多针对Java语言编码过程的优化措施来降低程序员的编码复杂度。

一些语法糖
1. 泛型
2. 自动装箱、拆箱
3. 遍历循环
4. 变长参数
5. 条件编译
6. ...

## 泛型
泛型的本质是参数化类型或者参数化多态的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数能够在类、借口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。

### Java和C#的泛型
Java选择的泛型实现方式叫做类型擦除式泛型，C#选择的泛型实现方式是具现化式泛型。C#中的泛型无论在程序源码里面、编译后的中间语言表示还是在运行期的CLR里面都是切实存在的。而Java语言中的泛型只在程序源码中，编译后的字节码里面，全部泛型都被替换成了原来的裸类型，并且在相应的地方加入了强制转换代码。

Java不支持的泛型用法
1. 无法对泛型进行实例判断`instanceof`
2. 无法使用泛型创建对象
3. 无法使用泛型创建数组

而且在性能上，两种实现也有差距，唯一的优势在于实现这种泛型的影响范围比较小，几乎只需要在javac编译器上做出改进即可，不需要改动字节码也不需要改动虚拟机，也保证了以前没有使用泛型的库可以直接运行。

JCP组织对虚拟机规范做了相应的修改，引入了`Signature`、`LocalVariableTypeTable`等新的属性用于解决伴随泛型而来的参数类型的识别问题。`Signature`存储了一个方法在字节码层面的特征签名，这个属性保存了参数化类型的信息。所以类型擦除仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们在编码时能通过反射手段获得参数化类型的根本依据。


## 条件编译
可以使用条件为常量的`if`语句。
