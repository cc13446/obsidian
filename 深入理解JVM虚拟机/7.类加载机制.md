# 虚拟机类加载机制
代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步

语言上的约定：
1. 实际情况中，每个Class文件都有代表着Java语言中的一个类或接口的可能
2. Class文件是一串二进制字节流，无论其以何种形式存在

## 类加载的流程
一个类型从被加载到虚拟机内存中开始到卸载出内存为止，他的整个生命周期将会经历
1. 加载
2. 验证
3. 准备
4. 解析
5. 初始化
6. 使用
7. 卸载

其中验证、准备、解析三个部分统称为连接。
![[Pasted image 20220508172750.png]]
加载、验证、准备、初始化、卸载这五个阶段开始的顺序是确定的，解析阶段在有些情况下可能会在初始化之后来支持Java语言的运行时绑定。这些节点完成的顺序是不一定的，他们会在一个阶段执行的过程中调用另一个阶段，所以是互相交叉的混合进行的。


## 初始化的时机
类什么时候开始第一个阶段的加载是虚拟机自由实现的，但是对于初始化阶段，Java虚拟机规范严格规定了只有六种情况必须立即对类进行初始化
1. 遇到四条字节码的时候
	1. `new`：实例化对象
	2. `getstatic`：设置静态字段（不被final修饰）
	3. `putstatic`：读取静态字段（不被final修饰）
	4. `invokestatic`：调用静态方法
2. 对类型进行反射调用的时候
3. 初始化类时，如果父类没有初始化则要先初始化父类
4. 虚拟机启动时，要制定执行的主类，虚拟机会先初始化主类
5. 使用JDK 7新加入的动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果为以下四种类型的方法句柄，并且这个方法句柄对应的类没有初始化的时候
	1. `REF_getStatic`
	2. `REF_putStatic`
	3. `REF_invokeStatic`
	4. `REF_newInvokeSpecial`
6. 当一个接口中定义了JDK8新加入的默认方法时，如果有这个接口的实现类初始化，先初始化接口

这六种场景中的行为称为对一个类型进行主动引用，除此之外所有引用类型的方式都不会触发初始化，称为被动引用。
1. 通过子类引用父类的静态字段，子类不会初始化
2. 通过数组定义来引用类，不会触发此类的初始化
3. 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类

接口也有初始化过程，编译器也会为接口生成`<clinit>()`类构造器，虽然接口不能使用静态代码块。当一个接口被初始化的时候，并不要求其父接口全部完成初始化，什么时候用才会初始化。

## 类加载的过程
### 加载
三件事
1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将字节流代表的静态存储结构转化为方法区的运行时数据结构
3. 内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口

相对于类加载过程的其他阶段，非数组类型加载阶段中获取二进制字节流这一步骤是开发人员可控性最强的阶段。开发人员既可以使用Java虚拟机里内置的引导类加载器来完成，也可以用用户自定义的类加载器去完成。

对于数组类，情况就不一样了，数组类本身不通过类加载器创建，而是由Java虚拟机在内存中动态构建出来。但是数组的元素类型还是要靠类加载器加载。数组类的创建过程有以下规则：
1. 如果数组的组件类型是引用类型，就递归的加载这个组件类型。
	- 数组将被标识在加载该组件类型的类加载器的类名称空间上。
	- 一个类型和他的类加载器一起确定唯一性
2. 如果数组的组件类型不是引用，Java虚拟机将数组标记为与引导类加载器相关联
3. 数组类的可访问性与他的组件类型的可访问性一致，组件类型不是引用类型则默认为`Public`

### 验证
连接阶段的第一步，确保字节流中的内容完全符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机本身的安全。

#### 文件格式验证
验证是否符合Class文件格式的规范，并能被当前版本的虚拟机处理
1. 魔数开头
2. 主次版本号能被虚拟机支持
3. 常量池表中是否有不被支持的常量类型
4. 常量的索引值中是否有指向不存在的常量或者不符合类型的常量
5. ....

主要目的是保证输入的字节流能被正确的解析并存在方法区之内。通过这个阶段，这段字节流进入虚拟机的方法区中进行存储。

#### 元数据验证
第二阶段对字节码描述的信息进行语义分析，保证其描述的信息符合《Java语言规范》的要求
1. 是否有父类
2. 是否继承了final类
3. 如果不是抽象类，是否有方法未实现
4. 字段、方法与父类是否矛盾
5. ...

#### 字节码验证
最复杂的一个阶段，通过数据流和控制流分析，确定程序语义是合法的，检查方法体，确保类的方法运行的时候不会损害哦虚拟机安全。
1. 操作数栈的数据类型与指令代码序列能配合工作，不存在放置int，按照long读取的情况
2. 保证跳转指令不会跳转到方法体以外
3. 类型转换总是有效的
4. ...

通过程序去校验程序逻辑是无法做到绝对准确的，所以无法保证验证之后一定安全。JDK 6之后Javac编译器可以辅助进行字节码验证，给方法体Code属性的属性表里面增加了`StackMapTable`的新属性，描述了方法体所有基本块开始时本地变量表和操作栈应有的状态，虚拟机只要检查`StackMapTable`属性中的记录是否合法就可以了。字节码验证的类型推导可以转变为类型检查，节省了大量校验时间。

#### 符号引用验证
发生在虚拟机将符号转化为直接引用的时候，这个转化动作将在连接的第三阶段`解析`中发生。检查该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源
1. 符号引用中通过字符串描述的全限定名能否找到相应的类
2. 指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段
3. 符号饮用中的类、字段、方法的可访问性是否能被当前类访问
4. ...

### 准备
正式为类中定义的变量`静态变量`分配内存并设置初始值的阶段。这些变量所使用的内存都应该在方法区分配。还有两个容易混淆的概念：
1. 进行内存分配的只有类变量，不包括实例变量
2. 初始值为数据类型的零值，不是类定义中的赋值，赋值在初始化阶段的类构造器`clinit()`方法
	- `final`修饰的常量会直接赋值

### 解析
将常量池内的符号引用替换为直接引用的过程
- 符号引用：用一组符号来描述所引用的目标，符号可以是任何形式的字面量
	- 虚拟机规范里有规定，与虚拟机实现的内存布局无关，各种虚拟机能接受的符号引用一致
- 直接引用：直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。
	- 与虚拟机实现的内存布局有关，如果有直接引用那么目标一定已经在内存中存在了

虚拟机可以自行判断在类加载的时候就对常量池表中的符号引用解析还是等到符号引用要被使用之前再去解析它，虚拟机规范规定了在执行17个用于操作符号引用的字节码指令之前解析。

对方法或者字段的访问，也要在解析阶段对他们的可访问性进行检查。除了`invokedynamic`指令以外，解析的结果应该一致保持一致。虚拟机可以对第一次的解析结果进行缓存。`invokedynamic`指令用于动态语言支持，动态指必须等到程序实际运行到这条指令时解析动作才能执行。

#### 类或者接口的解析
假设当前代码所处的类为***D***，要把一个从未解析过的符号引用***N***，解析为一个类或接口***C***的直接引用
1. C不是一个数组类型，虚拟机将会把代表N的全限定名传递给D的类加载器去加载C。
	- C的加载过程中有可能触发其他类的加载，一旦这个加载过程中出现任何异常，解析失败
2. C是一个数组类型，并且数组的元素类型为对象，N的描述符类似`[Ljava/lang/Integer`的形式，按照***1***的规则加载数组元素类型。接着虚拟机生成代表该数组维度和元素的数组对象
3. 如果上面没有任何异常，那么C在虚拟机中成为了有效的类或者接口，但还要确认访问权限

JDK 9引入模块化以后，Public类型不再意味着程序任何位置都有访问权限，至少下面成立一个
1. C是public的，与访问类D处于同一个模块
2. C是public的，与访问类D不在同一个模块，但是C的模块允许访问类D的模块访问
3. C不是public的，但是它与访问类D处于同一个包中

#### 字段解析
要解析一个未被解析过的字段符号引用，首先对字段表内`class_index`项中索引的`CONSTANT_Class_info`符号引用进行解析，也就是字段所属的类或者接口的符号引用。解析完成之后，把这个字段所属的类或者接口用***C***表示，然后：
1. C本身包含了简单名称和字段描述符都匹配的字段，则返回这个字段的直接引用，结束
2. 否则，如果在C中实现了接口，按照继承关系从下往上递归搜索接口和父接口
3. 否则，如果C不是`Object`的话，按照继承关系从下往上递归搜索其父类
4. 否则，查找失败，抛出`NoSuchFieldError`异常

成功返回引用之后，进行权限验证，如果发现不具备访问权限，抛出`IllegalAccessError`异常

#### 方法解析
也需要先解析出来方法表的`class_index`项中索引的方法所属类或者接口的符号引用，解析完成之后，用***C***表示这个类，然后：
1. 类的方法和接口的方法符号引用的常量类型定义是分开的，在类的方法表中发现`class_index`中索引的C是个接口的话抛出`IncompatibleClassChangeError`
2. 在C中查找是否简单名称和描述符都与目标匹配的方法
3. 在C的父类中递归查找
4. 在C的接口列表和父接口中查找，如果存在匹配的方法，说明C是抽象类，这时查找结束，并且要抛出`AbstractMethodError`异常
5. 否则，查找失败，抛出`NoSuchMethodError`异常

成功返回引用之后，进行权限验证，如果发现不具备访问权限，抛出`IllegalAccessError`异常

#### 接口方法解析
也需要先解析出来方法表的`class_index`项中索引的方法所属类或者接口的符号引用，解析完成之后，用***C***表示这个接口，然后：
1. 发现C是个类，抛出`IncompatibleClassChangeError`
2. 否则在接口C中查找
3. 否则在父接口中递归查找，直到`Object`类，包括`Object`类的方法
	- Java接口支持多继承，只返回一个匹配的就可以了
4. 否则，查找失败，抛出`NoSuchMethodError`异常

JDK 9之前接口中的所有方法都默认是public的，JDK 9增加了接口的静态私有方法，也有了模块。

### 初始化
类加载阶段的最后一个步骤，之前的阶段除了加载阶段用户可以自定义类加载器来参与以外都是虚拟机主导，初始化阶段才开始真正执行类中的Java程序代码。

初始化阶段就是执行`<clinit>()`方法的过程，他是Java编译器的自动生成物。收集了所有类变量的赋值动作和静态语句块中的语句，顺序是语句在源文件中出现的顺序决定的。静态语句块只能访问定义在静态语句块之前的变量。后面定义的变量可以赋值，但是不可以访问。

`<clinit>()`方法与`<init>()`方法不同，不需要显示的调用父类构造器，虚拟机会保证父类先调用。`<clinit>()`方法对于类和接口来说不是必须的，没有静态语句块和静态变量的赋值的话可以不生成。接口的`<clinit>()`方法不需要先执行父接口的`<clinit>()`方法，而是使用的时候再初始化父接口。Java虚拟机必须保证`<clinit>()`方法正确的加锁同步执行，有可能造成阻塞。

