# 垃圾收集
## 判断对象是否死亡
### 引用计数算法
给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。

### 可达性分析算法
通过 `GC Roots` 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。

在 Java 中 `GC Roots` 一般包含以下内容:
- 虚拟机栈中引用的对象
- 本地方法栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象
- 虚拟机内部的引用：基本数据类型的Class对象、常驻异常对象、系统类加载器等
- 所有被同步锁持有的对象
- 反应Java虚拟机内部情况的JMXBean、JVM TI中注册的回掉、本地代码缓存等
- 根据垃圾收集器和内存区域的不同，还有其他对象

### 引用类型
无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。

Java 具有四种强度不同的引用类型。

#### 强引用
被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。

```java
Object obj = new Object();
```
#### 软引用

被软引用关联的对象只有在内存不够的情况下才会被回收。

使用 `SoftReference` 类来创建软引用。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

#### 弱引用

被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。

使用 `WeakReference` 类来实现弱引用。

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

#### 虚引用

又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。

使用 `PhantomReference` 来实现虚引用。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj = null;
```

### finalize() 方法
当被可达性分析判定为不可达之后，会被第一次标记，如果对象的`finalize()` 方法没有被覆盖或者执行过，就会被直接回收。否则将对象放到`F-Queue`队列中，并在稍后由一个虚拟机自动建立的、低优先级的`Finalize`线程去执行他们的 `finalize()` 方法，但是并不承诺这个方法会执行完。如果在这个方法执行的过程中再次建立了连接，就会在第二次标记时将它移出即将回收的集合。

注意：
1. `finalize()` 方法对象的一生只执行一次
2. 已经被弃用了

### 回收方法区
《Java虚拟机规范》并没有要求虚拟机在方法区中实现垃圾回收，相比之下，方法区回收的判定条件更苛刻，而且进行回收的性价比也不高。

方法区的垃圾回收主要有两部分
1. 废弃的常量
2. 不再使用的类型

判断一个常量是否废弃的条件为：已经没有任何对象引用常量池中的常量，虚拟机中也没有其他地方引用这个字面量。

判断一个类型不再使用的条件：
1. 该类所有实例都回收，而且也不存在其派生子类的实例
2. 该类的类加载器已经被回收，除非精心设计过可替换类加载器的场景否则很难达成
3. 该类对应的Class对象没有在任何地方被引用，无法通过反射访问

## 垃圾收集算法
### 分代收集理论
两个假说：
1. 弱分代假说：绝大部分对象都是朝生夕灭的
2. 强分代假说：熬过越多次垃圾收集的对象越难以消灭

Java基于这两个假说，将堆分为新生代和老年代两个区域，分别进行不同频率的垃圾收集，但是有可能会存在跨代引用，进行新生区内的垃圾收集的时候可能要把老年区的所有对象放在`GC roots`中，这样会带来很大的性能负担，所以加入了第三个假说：
- 跨代引用假说：跨代引用相对于同代引用来说占极少数

这样只需要在新生代上建立一个全局的数据结构：记忆集，把老年代分为很多小块，标识出存在跨代引用的小块内存，这样进行新生代垃圾收集的时候只需要把存在跨代引用的小块内存加入`GC roots`就可以了。

不同的垃圾回收
1. 部分收集：目标不是完整收集整个Java堆的垃圾收集
	- 新生代收集
	- 老年代收集
	- 混合收集：只有G1会有这种行为
2. 整堆收集

### 标记-清除算法
首先标记处所有需要回收的对象，在标记完成之后统一回收掉所有被标记的对象。

缺点：
1. 执行效率不稳定，两个过程的执行效率与对象数量强相关
2. 内存空间有碎片化问题

### 标记-复制算法
将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是只使用了内存的一半。

现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 `Eden` 空间和两块较小的 `Survivor` 空间，每次使用 `Eden` 空间和其中一块 `Survivor`。在回收时，将 `Eden` 和 `Survivor` 中还存活着的对象一次性复制到另一块 `Survivor` 空间上，最后清理 `Eden` 和使用过的那一块 `Survivor`。

`HotSpot` 虚拟机的 `Eden` 和 `Survivor` 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 `Survivor` 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。

### 标记-整理算法

让所有存活的对象向内存空间一端移动，然后直接清理掉边界以外的内存。

## HotSpot的算法实现细节
### 根节点枚举
所有的收集器在根节点枚举这一步骤时都必须暂停用户线程，因此跟节点枚举和整理内存碎片一样，都会面临`stop the world`的困扰。

目前主流Java虚拟机使用的是准确式垃圾收集，当用户线程停顿下来之后，并不需要一个不漏的检查完所有执行上下文和全局的引用位置。虚拟机应当有方法知道哪些地方存着对象引用，HopSpot中使用一组`OopMap`的数据结构来达到这个目的。类加载完成的时候，它会把对象内什么偏移量是什么类型的数据计算出来。

### 安全点
在`OopMap`的协助下，HotSpot可以快速准确的完成`Gc Roots`枚举，但是导致`OopMap`变化的指令非常多，我们不能每执行一个指令就生成一个`OopMap`。HotSpot只在特定的位置才生成`OopMap`，这些位置就叫安全点。有了安全点之后，就不能在任意的位置都能停顿下来进行垃圾收集了，而是要必须执行到安全点之后才能暂停。

安全点位置的选取不能太少也不能太频繁，位置的选取以**是否具有让程序长时间执行的特征**为标准选定的，最明显的就是指令序列复用，例如方法调用、循环跳转、异常跳转等。这些指令的运行时间都比较长，只有具有这些功能的指令才会产生安全点。

还有一个问题就是如何让所有的线程都跑到安全点然后停下来。两种方式：
1. 抢先式中断：先把线程都中断，没到安全点的继续跑到安全点
2. 主动式中断：设置一个标志位，线程发现标志为在安全点主动挂起
	 - 轮询标志位放在安全点和需要在Java堆上分配内存的地方
	 - HotSpot虚拟机把`0X160100`内存设置为不可读作为标志
	 - 轮询使用内存保护陷阱的方式，线程执行`test`指令产生自陷异常信号来实现挂起

### 安全区域
当线程已经被挂起的时候，没法跑到安全点再挂起，这个时候就需要安全区域的概念。安全区域指能够确保某一代码片段内，引用关系不会发生变化，因此在这个区域中任何地方开始垃圾收集都是安全的。可以将其看作拉伸的安全点。线程进入安全区域的时候会标识自己进入了安全区域，离开安全区域的时候要检查虚拟机是否正在根节点枚举，如果没有完成根节点枚举就等待完成，否则就当做无事发生。

### 记忆集与卡表
记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构，最简单的实现可以用非收集区域中所有含跨代引用的对象数组对象数组来实现。当然设计者在实现记忆集的时候，可以选择更加粗旷的记录粒度来节省记忆集的存储和维护成本：
- 字长精度：也就是精确到指针
- 对象精度：这个对象有字段含有跨代指针
- 卡精度：一块内存区域内有对象含有跨代指针

卡精度采用了一种称为卡表的方式去实现记忆集，它定义了记忆集的精度、与堆内存的映射关系等。卡表最简单的形式可以只是一个字节数组，里面每个元素都对应着其标识的内存区域中一块特定大小的内存，这块内存叫做**卡页**，卡页的大小一般是2的整数幂。如果卡页内有一个或者更多对象的字段存在着跨代指针，就将对应卡表的数组元素的值标识为1，称这个元素变脏。垃圾收集的时候，只要处理变脏的卡表就可以了。

```c
CARD_TABLE[this_address >> 9] = 1;
```

### 写屏障
卡表什么时候变脏呢？有其他分代区域中对象引用了本区域对象的时候，其对应的卡表元素就应该变脏，原则上变脏应该发生在引用类型字段复制的那一刻。

卡表如何变脏呢？HotSpot虚拟机通过写屏障技术来维护卡表状态。写屏障可以看作虚拟机对引用字段赋值这个动作的AOP切面。引用对象赋值的时候会产生一个环形通知，赋值前是写前屏障，赋值后是写后屏障。
```c
void oop_field_store(oop* field, oop new_value) {
	// 赋值
	*field = new_value;
	// 写后屏障
	post_write_barrier(field, new_value);
}
```

卡表在高并发场景下还存在伪共享的问题。

#### 伪共享问题
卡表在内存上的存储是连续的，那么连续的两个元素通常会被加载到相同的`cpu cache line`里面。并发情况下，如果一个线程修改了`i`，会导致整个`cache line`失效(包括`i+1`)，这时另一个线程来读`i+1`，就需要从内存里再次加载了，这种多线程频繁修改的情况下，虽然`i`和`i+1`看似独立，但它们会互相干扰(写回、无效化、同步)，非常影响性能。

一种避免伪共享的简单解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有卡表元素未被标记过的时候才将其标记为脏。

### 并发的可达性分析

三色标记法：
1. 白色：表示对象未被垃圾回收器访问过，开始时都是白色，结束时白色的对象不可达
2. 黑色：对象已经被收集器访问过，而且对象的所有引用都扫描过，它是安全存活的
3. 灰色：表示对象已经被垃圾收集器访问过，但是还至少存在一个引用还没被扫描过

可达性分析的扫描过程可以看作对象图上一股以灰色为波峰的波纹从黑向白推进的过程。如果用户线程与收集器是并发工作的，会出现两种情况
1. 把原本消亡的对象标记为存活，这个可以容忍
2. 把原本存活的对象标记为消亡，这个非常致命

#### 错标
![[Pasted image 20220507221801.png]]

#### 错杀
需要满足两个条件
1. 赋值器插入了一条或多条从黑色到白色的新引用
2. 赋值器删除了全部从灰色对象到白色对象的直接或者间接引用
![[Pasted image 20220507221832.png]]

只要破坏错杀的的两个条件中的任意一个即可，两种方案
1. 增量更新
2. 原始快照

#### 增量更新
破坏第一个条件，黑色对象插入新的指向白色对象的引用关系时，将这个新的引用记录下来，等并发扫描结束之后，再将这些记录中的引用关系中的黑色对象为根，重新扫描一次。可以简单理解为，黑色对象一旦新插入了指定白色对象的引用后，重新变回灰色。

#### 原始快照
破坏第二个条件，当灰色对象要删除指向白色对象的引用时，将这个引用记录下来，等并发扫描结束之后，再将记录中的引用关系中的灰色对象为根，重新扫描一次，也就是说无论引用关系是否删除，都按照刚刚开始扫描的那一刻快照来进行搜索。

# 经典垃圾收集器
如果两个收集器之间存在连线，说明可以搭配使用。
![[Pasted image 20220507225629.png]]
### Serial收集器
最悠久、最基础的收集器，在它进行垃圾收集的时候是单线程工作的，而且必须暂停其他所有工作线程，直到收集结束。虽然需要`stop the world`，但是简单而高效，消耗内存最少。
![[Pasted image 20220507231152.png]]

### ParNew收集器
实质上是Serial收集器的多线程并行版本，除了使用多条线程进行垃圾收集以外，其他行为和Serial收集器完全一致。默认开启的收集线程数和处理器核心数量相同。
![[Pasted image 20220507231824.png]]
### Parallel Scavenge 收集器
