# 垃圾收集
## 判断对象是否死亡
### 引用计数算法
给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。

### 可达性分析算法
通过 `GC Roots` 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。

在 Java 中 `GC Roots` 一般包含以下内容:
- 虚拟机栈中引用的对象
- 本地方法栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象
- 虚拟机内部的引用：基本数据类型的Class对象、常驻异常对象、系统类加载器等
- 所有被同步锁持有的对象
- 反应Java虚拟机内部情况的JMXBean、JVM TI中注册的回掉、本地代码缓存等
- 根据垃圾收集器和内存区域的不同，还有其他对象

### 引用类型
无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。

Java 具有四种强度不同的引用类型。

#### 强引用
被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。

```java
Object obj = new Object();
```
#### 软引用

被软引用关联的对象只有在内存不够的情况下才会被回收。

使用 `SoftReference` 类来创建软引用。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

#### 弱引用

被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。

使用 `WeakReference` 类来实现弱引用。

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

#### 虚引用

又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。

使用 `PhantomReference` 来实现虚引用。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj = null;
```

### finalize() 方法
当被可达性分析判定为不可达之后，会被第一次标记，如果对象的`finalize()` 方法没有被覆盖或者执行过，就会被直接回收。否则将对象放到`F-Queue`队列中，并在稍后由一个虚拟机自动建立的、低优先级的`Finalize`线程去执行他们的 `finalize()` 方法，但是并不承诺这个方法会执行完。如果在这个方法执行的过程中再次建立了连接，就会在第二次标记时将它移出即将回收的集合。

注意：
1. `finalize()` 方法对象的一生只执行一次
2. 已经被弃用了

### 回收方法区
《Java虚拟机规范》并没有要求虚拟机在方法区中实现垃圾回收，相比之下，方法区回收的判定条件更苛刻，而且进行回收的性价比也不高。

方法区的垃圾回收主要有两部分
1. 废弃的常量
2. 不再使用的类型

判断一个常量是否废弃的条件为：已经没有任何对象引用常量池中的常量，虚拟机中也没有其他地方引用这个字面量。

判断一个类型不再使用的条件：
1. 该类所有实例都回收，而且也不存在其派生子类的实例
2. 该类的类加载器已经被回收，除非精心设计过可替换类加载器的场景否则很难达成
3. 该类对应的Class对象没有在任何地方被引用，无法通过反射访问

## 垃圾收集算法
### 分代收集理论
两个假说：
1. 弱分代假说：绝大部分对象都是朝生夕灭的
2. 强分代假说：熬过越多次垃圾收集的对象越难以消灭

Java基于这两个假说，将堆分为新生代和老年代两个区域，分别进行不同频率的垃圾收集，但是有可能会存在跨代引用，进行新生区内的垃圾收集的时候可能要把老年区的所有对象放在`GC roots`中，这样会带来很大的性能负担，所以加入了第三个假说：
- 跨代引用假说：跨代引用相对于同代引用来说占极少数

这样只需要在新生代上建立一个全局的数据结构：记忆集，把老年代分为很多小块，标识出存在跨代引用的小块内存，这样进行新生代垃圾收集的时候只需要把存在跨代引用的小块内存加入`GC roots`就可以了。

不同的垃圾回收
1. 部分收集：目标不是完整收集整个Java堆的垃圾收集
	- 新生代收集
	- 老年代收集
	- 混合收集：只有G1会有这种行为
2. 整堆收集

### 标记-清除算法
首先标记处所有需要回收的对象，在标记完成之后统一回收掉所有被标记的对象。

缺点：
1. 执行效率不稳定，两个过程的执行效率与对象数量强相关
2. 内存空间有碎片化问题

### 标记-复制算法
将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是只使用了内存的一半。

现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 `Eden` 空间和两块较小的 `Survivor` 空间，每次使用 `Eden` 空间和其中一块 `Survivor`。在回收时，将 `Eden` 和 `Survivor` 中还存活着的对象一次性复制到另一块 `Survivor` 空间上，最后清理 `Eden` 和使用过的那一块 `Survivor`。

`HotSpot` 虚拟机的 `Eden` 和 `Survivor` 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 `Survivor` 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。

### 标记-整理算法

让所有存活的对象向内存空间一端移动，然后直接清理掉边界以外的内存。

## HotSpot的算法实现细节
### 根节点枚举
所有的收集器在根节点枚举这一步骤时都必须暂停用户线程，因此跟节点枚举和整理内存碎片一样，都会面临`stop the world`的困扰。

目前主流Java虚拟机使用的是准确式垃圾收集，当用户线程停顿下来之后，并不需要一个不漏的检查完所有执行上下文和全局的引用位置。虚拟机应当有方法知道哪些地方存着对象引用，HopSpot中使用一组`OopMap`的数据结构来达到这个目的。类加载完成的时候，它会把对象内什么偏移量是什么类型的数据计算出来。

### 安全点
在`OopMap`的协助下，HotSpot可以快速准确的完成`Gc Roots`枚举，但是导致`OopMap`变化的指令非常多，我们不能每执行一个指令就生成一个`OopMap`。HotSpot只在特定的位置才生成`OopMap`，这些位置就叫安全点。有了安全点之后，就不能在任意的位置都能停顿下来进行垃圾收集了，而是要必须执行到安全点之后才能暂停。

安全点位置的选取不能太少也不能太频繁，位置的选取以**是否具有让程序长时间执行的特征**为标准选定的，最明显的就是指令序列复用，例如方法调用、循环跳转、异常跳转等。这些指令的运行时间都比较长，只有具有这些功能的指令才会产生安全点。

还有一个问题就是如何让所有的线程都跑到安全点然后停下来。两种方式：
1. 抢先式中断：先把线程都中断，没到安全点的继续跑到安全点
2. 主动式中断：设置一个标志位，线程发现标志为在安全点主动挂起
	 - 轮询标志位放在安全点和需要在Java堆上分配内存的地方
	 - HotSpot虚拟机把`0X160100`内存设置为不可读作为标志
	 - 轮询使用内存保护陷阱的方式，线程执行`test`指令产生自陷异常信号来实现挂起

### 安全区域
当线程已经被挂起的时候，没法跑到安全点再挂起，这个时候就需要安全区域的概念。安全区域指能够确保某一代码片段内，引用关系不会发生变化，因此在这个区域中任何地方开始垃圾收集都是安全的。可以将其看作拉伸的安全点。线程进入安全区域的时候会标识自己进入了安全区域，离开安全区域的时候要检查虚拟机是否正在根节点枚举，如果没有完成根节点枚举就等待完成，否则就当做无事发生。

### 记忆集与卡表
记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构，最简单的实现可以用非收集区域中所有含跨代引用的对象数组对象数组来实现。当然设计者在实现记忆集的时候，可以选择更加粗旷的记录粒度来节省记忆集的存储和维护成本：
- 字长精度：也就是精确到指针
- 对象精度：这个对象有字段含有跨代指针
- 卡精度：一块内存区域内有对象含有跨代指针

卡精度采用了一种称为卡表的方式去实现记忆集，它定义了记忆集的精度、与堆内存的映射关系等。卡表最简单的形式可以只是一个字节数组，里面每个元素都对应着其标识的内存区域中一块特定大小的内存，这块内存叫做**卡页**，卡页的大小一般是2的整数幂。如果卡页内有一个或者更多对象的字段存在着跨代指针，就将对应卡表的数组元素的值标识为1，称这个元素变脏。垃圾收集的时候，只要处理变脏的卡表就可以了。

```c
CARD_TABLE[this_address >> 9] = 1;
```

### 写屏障
卡表什么时候变脏呢？有其他分代区域中对象引用了本区域对象的时候，其对应的卡表元素就应该变脏，原则上变脏应该发生在引用类型字段复制的那一刻。

卡表如何变脏呢？HotSpot虚拟机通过写屏障技术来维护卡表状态。写屏障可以看作虚拟机对引用字段赋值这个动作的AOP切面。引用对象赋值的时候会产生一个环形通知，赋值前是写前屏障，赋值后是写后屏障。
```c
void oop_field_store(oop* field, oop new_value) {
	// 赋值
	*field = new_value;
	// 写后屏障
	post_write_barrier(field, new_value);
}
```

卡表在高并发场景下还存在伪共享的问题。

#### 伪共享问题
卡表在内存上的存储是连续的，那么连续的两个元素通常会被加载到相同的`cpu cache line`里面。并发情况下，如果一个线程修改了`i`，会导致整个`cache line`失效(包括`i+1`)，这时另一个线程来读`i+1`，就需要从内存里再次加载了，这种多线程频繁修改的情况下，虽然`i`和`i+1`看似独立，但它们会互相干扰(写回、无效化、同步)，非常影响性能。

一种避免伪共享的简单解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有卡表元素未被标记过的时候才将其标记为脏。

### 并发的可达性分析

三色标记法：
1. 白色：表示对象未被垃圾回收器访问过，开始时都是白色，结束时白色的对象不可达
2. 黑色：对象已经被收集器访问过，而且对象的所有引用都扫描过，它是安全存活的
3. 灰色：表示对象已经被垃圾收集器访问过，但是还至少存在一个引用还没被扫描过

可达性分析的扫描过程可以看作对象图上一股以灰色为波峰的波纹从黑向白推进的过程。如果用户线程与收集器是并发工作的，会出现两种情况
1. 把原本消亡的对象标记为存活，这个可以容忍
2. 把原本存活的对象标记为消亡，这个非常致命

#### 错标
![[Pasted image 20220507221801.png]]

#### 错杀
需要满足两个条件
1. 赋值器插入了一条或多条从黑色到白色的新引用
2. 赋值器删除了全部从灰色对象到白色对象的直接或者间接引用

![[Pasted image 20220507221832.png]]

只要破坏错杀的的两个条件中的任意一个即可，两种方案
1. 增量更新
2. 原始快照

#### 增量更新
破坏第一个条件，黑色对象插入新的指向白色对象的引用关系时，将这个新的引用记录下来，等并发扫描结束之后，再将这些记录中的引用关系中的黑色对象为根，重新扫描一次。可以简单理解为，黑色对象一旦新插入了指定白色对象的引用后，重新变回灰色。

#### 原始快照
破坏第二个条件，当灰色对象要删除指向白色对象的引用时，将这个引用记录下来，等并发扫描结束之后，再将记录中的引用关系中的灰色对象为根，重新扫描一次，也就是说无论引用关系是否删除，都按照刚刚开始扫描的那一刻快照来进行搜索。

# 经典垃圾收集器
如果两个收集器之间存在连线，说明可以搭配使用。
![[Pasted image 20220507225629.png]]
### Serial收集器
最悠久、最基础的收集器，在它进行垃圾收集的时候是单线程工作的，而且必须暂停其他所有工作线程，直到收集结束。虽然需要`stop the world`，但是简单而高效，消耗内存最少。
![[Pasted image 20220507231152.png]]

### ParNew收集器
实质上是Serial收集器的多线程并行版本，除了使用多条线程进行垃圾收集以外，其他行为和Serial收集器完全一致。默认开启的收集线程数和处理器核心数量相同。
![[Pasted image 20220507231824.png]]
### Parallel Scavenge 收集器
Parallel Scavenge收集器和ParNew收集器十分相似，特点在于他的关注点和其他收集器不同，CMS等收集器的关注点是尽可能减少垃圾收集暂停用户线程的时间，而Parallel Scavenge收集器的目的是达到一个可控制的吞吐量。
![[Pasted image 20220508103115.png]]
### Serial Old收集器
Serial收集器的老年代版本，单线程收集器，使用标记整理算法。
![[Pasted image 20220507231152.png]]

### Parallel Old收集器
Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现
![[Pasted image 20220508103514.png]]

### CMS收集器
Concurrent Mark Sweep收集器是一种以获取最短回收停顿时间为目标的收集器，是基于标记-清除算法实现的：
1. 初始标记：标记`GC Roots`能直接关联到的对象
2. 并发标记：从直接关联对象开始遍历整个对象图
3. 重新标记：修正并发标记期间因为用户线程导致标记发生变动的那一部分对象的记录
4. 并发清除：清理删除掉死亡的对象

其中初始标记和重新标记需要`stop the world`
![[Pasted image 20220508104430.png]]
CMS收集器是HotSpot虚拟机追求低停顿的第一次成功尝试，但是有三个明显缺点
1. 处理器资源敏感，占用了一部分线程，吞吐量降低。默认回收线程是`(核心 + 3)/4`
2. 无法处理浮动垃圾，并发标记和并发清理阶段，会产生新的垃圾，所以要预留足够的空间供并发收集时的程序运作使用。当预留的内存无法满足程序分配新对象的需要时，要临时启用Serial Old收集器来重新进行老年代的垃圾收集。
3. 会产生很多内存碎片，可以设置在`Full GC`之前或者过程中进行碎片整理。

### Garbage First收集器
G1收集器是垃圾收集器技术发展历史上里程碑式的成功，开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。

规划JDK 10功能目标时，HotSpot提出了`统一垃圾收集器接口`，将内存回收的行为和实现进行分离，CMS和其他收集器都重构成基于这套接口的一个实现。

G1跳出了传统分代收集的思想，他可以面对堆内存任何部分来组成回收集`Collection Set`进行回收，衡量标准是那块内存中存放的垃圾数量最多，回收受益最大，这就是G1收集器的Mixed GC模式。

虽然G1仍然遵循分代收集理论设计，但是不在坚持固定大小和数量的分代区域设计，而是把Java堆分成多个大小相等的独立区域，每一个`Region`都可以根据需要扮演新生代的Eden空间、Survivor空间，或者老年代空间，收集器按照不同的策略去处理不同角色的空间。

Region还有一类特殊的Humongous区域，专门用来存储大对象，G1认为超过一个Region容量一半的对象即可判定为大对象。超级大对象将被存放在N个连续的Humongous区域中。G1的大多数行为都把Humongous区域作为老年代的一部分来看待。

G1将Region作为单次回收的最小单元，G1收集器去跟踪各个Region里面的垃圾堆积的价值大小，价值即回收所获得的空间以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值最大的那些Region。

对于跨Region引用，G1也维护了记忆集，每个Region都有自己的记忆集，记录下别的Region指向自己的指针，并标记这些指针对应在卡页的范围，存储结构的本质上是一种哈希表。Key是别的Region的起始地址，Value是卡表索引号的集合。

如何处理并发标记呢？CMS采用增量更新，G1采用原始快照算法实现。当回收过程中有新对象创建的时候， G1为每个Region设计了两个名为`TAMS:Top at Mark Start`的指针，把Region中的一部分空间划分出来用作并发回收过程中的新对象分配。并发回收时新分配的对象地址都必须要在这两个指针位置以上。 G1收集器默认在这个地址以上的对象被隐式标记过，默认他们是存活的。

大致分为四个步骤
1. 初始标记：标记`GC Roots`能直接关联到的对象，并且修改`TAMS`指针的值
	- 停顿线程，但是可以借用进行Minor GC的时候同步完成
2. 并发标记：对堆中的对象进行可达性分析，要重新处理一下`SATB`记录下引用变动的对象
3. 最终标记：暂停用户线程，用于处理并发阶段结束之后仍然遗留下来的小部分`SATB`记录
4. 筛选回收：更新Region的统计数据，进行排序，制定回收计划，可以选择任意多个Region构成回收集，然后把回收集中Region的存活对象复制到新的空Region中，在清理掉旧Region的全部空间。这里涉及到对象的移动，必须暂停用户线程，并发完成。

![[Pasted image 20220508113259.png]]
优点：
1. 由用户指定期望的停顿时间
2. 局部标记复制，全局标记整理，没有内存碎片

缺点：
1. 占用内存大
2. 维护卡表更复杂

## 低延迟垃圾收集器
衡量垃圾收集器三项最重要的指标
1. 内存占用
2. 吞吐量
3. 延迟

三者构成了一个不可能三角，三者的总体表现会越来越好，但是一个收集器最多可以同时达成其中的两项。延迟会成为垃圾收集器最被重视的性能指标。

### Shenandoah收集器
他的目标是实现一种能在任何堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的垃圾收集器。这就意味着不仅要进行并发的垃圾标记，还要并发的进行对象清理后的整理动作Shenandoah和G1有着相似的堆内存布局，在初始标记、并发标记等很多阶段的处理思路上都高度一致，甚至还直接共享了一部分实现代码。

三个与G1的不同
1. 支持与用户并发的整理算法
2. 默认不用分代收集
3. 抛弃了G1中耗费大量资源的记忆集，该用一个叫连接矩阵的全局变量来维护跨Region引用
	- 降低了维护消耗和伪共享的发生概率
	- 连接矩阵可以简单理解为一个二维表格，如果N有对象指向M，则`Array[N][M]`标记

九个阶段：
1. 并发标记：同G1，标记`GC Roots`直接关联的对象，`Stop the world`，时间与堆大小无关 
2. 并发标记：同G1，标记全部可达的对象，与用户线程并发
3. 最终标记：同G1，暂停用户线程，用于处理并发阶段结束之后仍然遗留下来的小部分`SATB`记录，还要统计出回收价值最高的回收集
4. 并发清理：清理对象全部死亡的Region
5. 并发回收：把回收集里面的存活对象复制一份到其他未被使用的Region中
	- 并发采用读屏障和`Brooks Pointers`转发指针实现
6. 初始引用更新：复制结束之后，还要把堆中所有指向旧对象的引用修正到复制后的新地址。实际上是为了建立一个线程集合点，确保所有线程完成了对象移动任务。有短暂的停顿
7. 并发引用更新：与用户线程一起并发，将旧值改为新值
	- 不沿着对象图搜索，按照物理内存的顺序线性搜索
8. 最终引用更新：修正`GC Roots`中的引用，停顿时间与`GC Roots`的数量相关
9. 并发清理

#### Brooks Pointer
传统的并发对象移动一般在原有的内存上设置保护陷阱，当用户线程访问到这个对象的时候就陷入中断，让中断把访问的对象转发到复制的新对象上，但是这样会在用户态和核心态频繁切换，代价很大。

Brooks提出的新方案不需要用的内存保护陷阱，而是在原有的对象布局结构最前面加个新的引用字段，正常不处于并发移动的情况下这个引用指向对象自己。这个转发指针和句柄定位有点相似，区别是句柄会放在句柄池里面，而转发指针会分散存储在每一个对象头前面。

并发写入出现在复制对象和更新转发指针引用之间的时候，会导致用户修改发生在旧对象上，所以这里必须对转发指针的访问操作采取同步措施，让收集器线程和用户线程对转发指针的访问只有其中之一可以成功，实际上这里使用CAS来保证并发时对象的访问正确性的。

Shenandoah在读写屏障都加入了额外的转发处理，由于读写屏障的庞大性能开销，JDK13计划将他的内存模型改为基于引用访问屏障的实现，而不去管原生数据类型的读写。

### ZGC收集器
ZGC 与 Shenandoah的目标高度相似，但是实现完全不同。

ZGC的内存布局也采用了Region，但是可以动态创建和销毁，X64硬件环境下，ZGC的Region有三种容量类型：
1. 小型：固定2MB，存放小于256KB的对象
2. 中型：固定32MB，存放大于256KB，小于4MB的对象
3. 大型：不固定，可以动态变化，但是是2MB的整数倍，存放大于等于4MB的对象
	- 最小可以只有4MB，不会被重分配

#### 并发整理算法的实现
采用染色指针技术，与之前需要在对象上存储一些额外信息不同，追踪式收集算法的标记阶段存在只跟指针打交道而不必涉及指针所引用的对象本身的场景，也就是说不读取对象而只通过对象的指针就能得到额外的信息，比如给对象打上三色标记，这些标记本质上只与对象的引用有关，而与对象本身无关。几种收集器有不同的标记实现方案
1. 标记在对象头上：Serial收集器
2. 标记在与对象相互独立的数据结构上：G1，Shenandoah利用BitMap记录
3. 染色指针：ZGC

#### 染色指针
染色指针是一种直接将少量额外信息储存在指针上的技术。64位系统中，理论可以进行64位的寻址，但是AMD64架构只支持52位的地址总线和48位的虚拟地址空间。此外操作系统也会加上自己的约束，64位的Linux支持47位的进程虚拟地址空间和46位的物理地址空间。64位的Windows系统只支持44位的物理地址空间。

染色指针技术将指针的高四位提取出来储存四个标志信息，通过这个标志位，虚拟机可以从指针看到引用的三色标记状态、是否进入了重分配集(被移动过)、是否只能通过`finalize()`方法才能访问到。这样导致ZGC管理的内存更少了，只有Linux下46-4=42位的物理地址空间，不可以超过4TB。

染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能被释放和重用，而不用等整个堆中所有指向该Region的引用都被修正才能清理。还大幅减少了垃圾收集中内存屏障的使用数量。

染色指针怎么正常寻址呢？只需要使用多对一的映射，将染色指针对应的虚拟地址都映射到同一个物理地址就可以了。比如`0x0000100012345678`和`0x0000080012345678`应该映射到同一个物理地址(忽略前四位标志位)

#### 运作过程
1. 并发标记：同G1，前后也要经过初始标记和最终标记的停顿阶段，但是通过染色指针标记
2. 并发预备重分配：通过查询条件统计出本次清理的Region，组成重分配集
	- ZGC每次回收都会扫描所有的Region，重分配集决定里面的对象会复制到其他的Region中
	- 在JDK 12中ZGC开始支持的类卸载和弱引用的处理也在这个阶段完成
3. 并发重分配：把重分配集中的存活对象复制到新的Region上，并为重分配集的每个Region维护一个转发表，记录从旧对象到新对象的转向关系。染色指针可以标识是否在转发集里。
4. 并发重映射：修正整个堆中指向重分配集中旧对象的所有引用，合并到了下一次并发标记
