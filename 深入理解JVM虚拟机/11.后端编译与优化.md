# 后端编译与优化
## 即时编译器
在HotSpot和OpenJDK里面，Java程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或者代码块儿的运行特别频繁，就会把这些代码认定为热点代码，运行时会把这些代码编译成本地机器码，并尽可能的对代码进行优化。

### 解释器和编译器
各有优势：
1. 当程序需要迅速启动和执行的时候，解释器先发挥作用，可以省去编译的时间
2. 程序启动之后，编译器发挥作用，把越来越多的代码编译为本地代码，获得更好的执行效率
3. 当程序运行环境中内存资源限制较大的时候，可以解释执行节约内存，反之可以用编译执行加速
4. 解释器还可以进行编译器激进优化时后备的逃生门，让编译器根据概率选择一些不能保证所有情况都正确，但是大多数时候都能提升运行速度的优化手段。当激进优化的假设不成立，可以通过逆优化退回到解释状态继续执行。

![[Pasted image 20220511154232.png]]
HotSpot内置的几种编译器
1. `Client Compiler`：客户端编译器、C1编译器
2. `Server Compiler`：服务端编译器、C2编译器
3. 实验状态的`Graal`编译器

由于即时编译器编译本地代码需要占用程序运行时间，优化程度越高的代码，花的时间会越长。而且为了编译出优化程度更高的代码，解释器还要替编译器收集性能监控信息，这对解释执行的速度也有影响。为了在程序响应速度与运行速度之间达到平衡，HotSpot虚拟机在编译子系统中加入了分层编译的功能，在JDK 7的服务端模式虚拟机中作为默认编译策略开启，包括
1. 第0层：程序纯解释执行，解释器不开启性能监控功能
2. 第1层：使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的性能优化，不开启性能监控功能
3. 第2层：仍然使用客户端编译器执行，仅开启方法以及回边次数统计等有限的性能监控功能
4. 第3层：使用客户端编译器，开启全部性能监控，加上了分支跳转、虚方法调用版本等统计信息
5. 第4层：使用服务端编译器，启用更多编译耗时更长的优化，根据性能监控信息进行激进优化

以上层次并不是固定不变的，根据不同的运行参数和版本，虚拟机可以调整分层的数量。实施分层编译之后，解释器、客户端编译器和服务端编译器就会同时工作，热点代码有可能会被多次编译。

### 编译对象和触发条件
热点代码有两类：
1. 被多次调用的方法
2. 被多次执行的循环体

对于两种情况，编译的目标对象都是整个方法体，而不是单独的循环体。第二种情况，热点只是方法的一部分，但是编译器必须以整个方法作为编译对象，只是执行入口会稍有不同，编译时会传入执行入口点字节码序号`Byte Code Index， BCL`。这种编译方式因为编译发生在方法执行的过程中，因此很形象的被称为栈上替换，即方法的栈帧还在栈上，方法就被替换了。

要知道代码是不是热点代码，需不需要触发即时编译，这个行为称为热点探测。
1. 基于采样的热点探测
2. 基于计数器的热点探测

#### 基于采样的热点探测
周期性的检查各个线程的调用栈顶，如果发现某个方法经常出现栈顶，那就是热点方法。
- 优点：实现简单高效、很容易获取方法调用关系
- 缺点：很难精确确认一个方法的热度，容易受到线程阻塞或者别的外界因素的影响

#### 基于计数器的热点探测
为每个方法甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为他是热点方法。HotSpot虚拟机使用的是这种方法，虚拟机为每个方法准备了两类计数器
1. 方法调用计数器：Invocation Counter
2. 回边计数器：Back Edge Counter
	- 回边的意思就是指在循环边界往回调转

##### 调用计数器
在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足让它提交给即时编译器编译，那该方法的调用计数器会被减少一半，这个过程叫热度的衰减，这段时间就称为此方法统计的半衰周期。进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以用虚拟机参数关闭，还可以设置半衰周期。
![[Pasted image 20220511172646.png]]

##### 回边计数器
回边计数器的阈值通过`-XX:OnStackReplacePercentage`设置`OSR`来间接的调整
1. 客户端模式下：`回边计数器阈值=方法调用计数器阈值 * OSR / 100`
2. 服务端模式下：`回边计数器阈值=方法调用计数器阈值 * (OSR - 解释器监控比率) / 100`

![[Pasted image 20220511182206.png]]
与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，他还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。

### 编译过程
默认条件下，虚拟机都在后台编译，可以`-XX:-BackgroundCompilation`来禁止后台编译，这样提交编译请求之后就会一直阻塞等待，直到编译过程完成在开始执行编译器输出的本地代码。

#### 客户端编译
相对简单快速的三段式编译器，主要的关注点在于局部的优化，而放弃了许多耗时较长的全局优化
1. 一个平台独立的前端将字节码构成一种高级中间代码表示`High-Level Intermediate Representation, HIR)`的形式，也就是与目标机器指令集无关的中间表示。
	- HIR使用静态单分配`Static Single Assignment, SSA`的形式来表示代码值
	- 这可以使得一些在HIR构造过程中和过程后进行的优化动作更容易实现。
	- 在此之前，编译器会在字节码上完成一部分基础优化，如方法内联、常量传播
2. 一个平台相关后端产生低级中间代码表示`Low-Level Intermediate Representation, LIR`
	- 而在此之前会在HIR上完成一些优化，以便HIR达到更高效的代码表示
	- 比如空值检查消除、范围检查消除
3. 在平台相关的后端使用线性扫描算法在LIR上分配寄存器，并在LIR上做窥孔`Peephole`优化，然后产生机器代码

![[Pasted image 20220511195011.png]]
#### 服务端编译
专门面向服务端的典型应用场景，并为服务端的性能配置针对性地调整过的编译器，也是一个能容忍很高优化复杂度的高级编译器，几乎能达到GNU C++编译器使用`-O2`参数时的优化强度。它会执行大部分经典的优化动作
- 无用代码消除
- 循环展开
- 循环表达式外提
- 消除公共子表达式
- 常量传播
- 基本块重排序

还会实施一些与Java语言密切相关的优化技术：
- 范围检查消除
- 空值检查消除
- ...

还可能根据解释器或者客户端编译器提供的性能监控信息，进行一些不稳定的预测性激进优化
- 守护内联
- 分支频率预测
- ...

服务器端编译采用的寄存器分配器是一个全局图着色分配器，他可以充分利用某些处理器架构上的大寄存器集合。

## 提前编译器
### 提前编译的优劣得失
现在提前编译产品有两条明显的分支
1. 与传统C、C++编译器类似，在程序运行之前把程序代码编译策划那个机器码的静态翻译工作
2. 把原本即时编译器在运行时要做的编译工作提前做好并保存起来，运行到这些代码时直接用

#### 传统的提前编译形式
因为编译时间不会在占用程序运行时间，所以可以做更多更耗时的全局优化

#### 给即时编译器做缓存加速
又叫动态提前编译，或者即使编译缓存。

## 即时编译器相对于提前编译器的天然优势
1. 性能分析制导优化
	- 一些性能监控信息：抽象类的类型、条件判断分支、方法调用版本等提前编译器不能知道
2. 激进预测优化
	- 性能监控信息可以支持即时编译器做一些正确的可能性很大，但无法保证绝对正确的预测
	- 万一真的走到罕见分支上，可以退回低级编译器甚至解释器
3. 链接时优化
	- 跨越动态连接库的方法内联

## 编译器优化技术
### 最重要的优化技术之一：方法内联
除了消除方法调用的成本以外，更重要的意义是为其他优化手段建立良好的基础。方法内联的优化行为理解起来没有任何困难，不过就是把目标方法的代码原封不动的复制到发起调用的方法中，避免发生真实的方法调用而已。但是因为虚方法的存在，必须在运行时进行方法接受者的多态选择，所以根据经典编译原理的优化理论，大多数的Java方法都无法进行内联。

为了解决虚方法的内联问题，Java虚拟机首先引入了一种名为类型继承关系分析`CHA`的技术，这是整个应用程序范围内的类型分析技术，用于确定在目前已加载的类中，某个接口是否有多于一种的实现，某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息。这样编译器在进行内联时就会分不同情况采取不同的处理：
1. 如果是非虚方法，那么直接进行内联
2. 如果是虚方法，在CHA中查询此方法在当前程序状态下是否有多个目标版本可供选择
	- 只查询到一个版本，可以假设应用程序的全貌就是这个样子来进行内联，也叫守护内联。但是这属于激进预测性优化，虚拟机一直没有加载到令这个方法的接受者继承关系发生变化的类，那代码就可以一直使用下去，否则就要退回到解释状态，或者重新进行编译。
	- 多个版本的目标方法可供选择，进行最后一次努力，使用内联缓存的方式来缩减方法调用开销
	
内联缓存是一个建立在目标方法调用入口之前的缓存，他的工作原理大致为：在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接受者的版本信息，并且每次进行方法调用时都比较接受者的版本。如果以后进来的每次调用的方法调用者版本都是一样的，那么此时它就是一种单态内联缓存。通过该缓存来调用，比不内联的非虚方法调用，仅多了一次类型判断的开销而已。如果真的出现方法接受者不一致的情况，就说明程序用到了虚方法的多态特性，这时候就会退化成多态内联缓存，其开销相当于真正查找虚方法表来进行方法分派。

### 最前沿的优化技术之一：逃逸分析
基本原理是：分析对象动态作用域，当一个对象在方法里面被定义后，他可能被外部方法所引用，这种称为方法逃逸。甚至可能被外部线程访问，这种称为线程逃逸。从不逃逸、方法逃逸到线程逃逸称为对象由低到高的不同逃逸程度。

如果能证明一个对象的逃逸程度，就可以为这个对象采取不同程度的优化：
1. 栈上分配：从不逃逸的对象可以在栈上进行分配，然后对象就会随着方法的结束自动销毁
2. 标量替换
	- 标量：一个数据无法被分解成更小的数据
	- 聚合量：一个数据可以继续分解
	- 标量替换：根据程序访问情况，把Java对象拆散，将其用到的成员恢复为原始数据来访问
	- 不逃逸的对象可以直接拆散，不去创建这个对象，改为创建被方法使用的成员变量来代替
3. 同步消除：没有线程逃逸的对象，可以消除同步措施

### 语言无关的经典优化技术之一：公共子表达式消除
如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。对于这种表达式没有必要花时间对它重新计算，只需要直接用前面计算过的表达式结果代替E。
- 局部公共子表达式消除：仅限于程序基本块内
- 全局公共子表达式消除：涵盖了多个基本块

### 语言相关的经典优化技术之一：数组边界检查消除
Java是一门动态安全的语言，访问数组元素的时候系统会自动进行上下界的范围检查。但是运行期不一定要一次不漏的进行，比如：
1. 数组下标是一个常量
2. 数组访问在循环之内