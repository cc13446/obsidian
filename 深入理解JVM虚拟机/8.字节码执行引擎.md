# 虚拟机字节码执行引擎
物理机的执行引擎直接建立在处理器、缓存、指令集和操作系统层面上，而虚拟机的执行引擎由软件自行实现，可以不受物理条件制约的定制指令集和执行引擎的结构体系。不同的虚拟机实现可能有解释执行和编译执行，还可能有即时编译器，但是从外观来看，所有执行引擎的输入输出都是一致的。

## 运行时栈帧结构
Java虚拟机以方法作为最基本的执行单元，栈帧是用于支持虚拟机进行方法调用和方法执行背后的数据结构，他也是虚拟机运行时数据区中的虚拟机栈的栈元素。每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译Java程序源码的时候，栈帧需要分配多少内存已经被分析计算出来，并且写到方法表的`Code`属性中，并不会受到程序运行期变量数据的影响
- 当前栈帧：只有位于栈顶的方法在运行，也只有栈顶的栈帧有效
- 当前方法：当前栈帧对应的方法

所有字节码指令都只针对当前栈帧进行操作。

### 局部变量表
存放了方法参数和方法内部定义的局部变量。Java程序被编译为Class文件的时候，就在方法的Code属性`max_locals`数据项中确定了该方法的局部变量表需要的最大容量。

局部变量表的容量以变量槽为单位，虚拟机规范没有明确指出一个变量槽应该占用的内存空间大小，只是导向的说每个变量槽都应该能存放一个`boolean`、`byte`、`char`、`short`、`int`、`float`、`reference`、`returnAddress`类型的数据。

对于64位的数据，`long`和`double`会被分配两个连续的变量槽空间，这与`long`和`double`的非原子协定：允许把一次`long`和`double`数据类型读写分为两次32位读写的做法类似。

#### reference
一个对象的引用，虚拟机规范没有固定长度和结构，只规定了功能：
1. 根据引用可以直接或者间接的查找到对象在Java堆中的数据地址或者索引
2. 根据引用查找到对象所属数据类型在方法区中存储的类型信息

#### returnAddress
目前已经很少见了，是为`jsr`，`jsr_w`，`ret`服务的，指向了一条字节码指令的地址，曾经有虚拟机用这些指令处理异常跳转，现在改为采用异常表实现了

虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0到局部变量表的最大变量槽数量。如果访问32位数据，索引N就代表使用了第N个变量槽，如果访问64位数据，索引N就代表了使用第N和N+1个变量槽。

当一个方法被调用时，虚拟机使用局部变量表来完成实参到形参的传递。如果是实例方法，第0位索引的变量槽默认是方法所属对象实例的引用，也就是`this`。

为了节省栈帧耗费的内存，变量槽是可以重用的，方法体中的变量作用域并不一定覆盖了整个方法体，如果当前字节码PC计数器超出了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来使用。这样会对垃圾收集行为有一些影响。当某些变量离开他的作用域，如果变量槽没有被其他变量重用，那么这个变量就不会被收集，因为局部变量表还存着他的引用，虽然以后这个变量以后也不会再使用了，所以给变量赋值为`null`来帮助`GC`的行为是可以理解的，但是实际上将变量设置为`null`的行为很可能被编译优化当作无效操作消除掉。

注意局部变量不会赋默认值，下面的代码不能运行：
```java
public static void main(String[] args) {
	int a;
	System.out.println(a);
}
```

### 操作数栈
最大深度也在编译的时候被写入到Code属性的`max_stacks`数据项之中，操作数栈中的每一个元素都可以是包括`long`和`double`的任意Java数据类型。

当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令进行入栈出栈的动作来帮助运算，或者调用其他方法的时候利用操作数栈来进行方法参数的传递。概念模型中两个不同的栈帧作为不同方法的虚拟机栈的元素是完全独立的，但是大多数虚拟机的实现会让栈帧出现一部分重叠，让下面栈帧的部分操作数栈和上面栈帧的部分局部变量表重叠在一起，可以节约空间并且减少额外的参数复制传递。
![[Pasted image 20220509220538.png]]


### 动态连接
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，这个引用为了支持方法调用中的动态连接。字节码中的方法调用指令就以常量池里指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候转化为直接引用，这叫静态解析。有一部分符号引用将在每一次运行期间转化为直接引用，这部分就叫动态连接。

### 方法返回地址
两种方式退出方法：
1. 执行引擎遇到任意一个方法返回的字节码指令，即正常调用完成
2. 方法执行过程中遇到了异常，而且这个异常在方法体内没有处理妥当，即异常调用完成
	- 没有返回值

方法退出之后，必须返回到最初方法被调用时的位置。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复他的上层主调方法的执行状态。
1. 方法正常退出时：主调方法的PC计数器的值可以作为返回地址
2. 方法异常退出时，返回地址要通过异常处理表来确定

方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作：
1. 回复上层方法的局部变量表和操作数栈
2. 把返回值压入调用者栈帧的操作数栈中
3. 调整PC计数器的值来指向方法调用指令后面的一条指令

### 附加信息
Java虚拟机规范允许虚拟机实现一些规范里没有描述的信息到栈帧，取决于实现

## 方法调用
方法调用不等于方法中的代码被执行，唯一的任务是确定被调用方法的版本。一切方法调用在Class文件中储存的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。这个方法给Java带来了更强大的动态扩展能力，但是Java的方法调用更复杂。

### 解析
所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分符号引用转化为直接引用。前提是：**方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期不可改变**。也就是说调用目标在编译器进行编译的时候已经确定下来。主要有静态方法和私有方法两大类。

调用不同的方法，有五种方法调用字节码指令：
1. `invokestatic`：调用静态方法
2. `invokespecial`：调用实例构造器`<init>()`方法，私有方法和父类方法
3. `invokevirtual`：调用虚方法
4. `invokeinterface`：调用接口方法，运行时确定一个实现该接口的对象
5. `invokedynamic`：先在运行时动态解析出调用点限定符所引用的方法，然后再执行

前四个调用指令的分派逻辑固化在Java虚拟机内部，最后一个指令的分派逻辑是由用户设定的引导方法决定的。

只要能被`invokestatic`和`invokespecial`指令调用的方法都可以在解析阶段确定唯一的版本
1. 静态方法
2. 私有方法
3. 实例构造器
4. 父类方法
5. final修饰的方法：`invokevirtual`调用，历史原因

这些方法被称为非虚方法，其他方法被称为虚方法。

### 分派


