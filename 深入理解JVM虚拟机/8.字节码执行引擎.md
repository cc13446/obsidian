# 虚拟机字节码执行引擎
物理机的执行引擎直接建立在处理器、缓存、指令集和操作系统层面上，而虚拟机的执行引擎由软件自行实现，可以不受物理条件制约的定制指令集和执行引擎的结构体系。不同的虚拟机实现可能有解释执行和编译执行，还可能有即时编译器，但是从外观来看，所有执行引擎的输入输出都是一致的。

## 运行时栈帧结构
Java虚拟机以方法作为最基本的执行单元，栈帧是用于支持虚拟机进行方法调用和方法执行背后的数据结构，他也是虚拟机运行时数据区中的虚拟机栈的栈元素。每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译Java程序源码的时候，栈帧需要分配多少内存已经被分析计算出来，并且写到方法表的`Code`属性中，并不会受到程序运行期变量数据的影响
- 当前栈帧：只有位于栈顶的方法在运行，也只有栈顶的栈帧有效
- 当前方法：当前栈帧对应的方法

所有字节码指令都只针对当前栈帧进行操作。

### 局部变量表
存放了方法参数和方法内部定义的局部变量。Java程序被编译为Class文件的时候，就在方法的Code属性`max_locals`数据项中确定了该方法的局部变量表需要的最大容量。

局部变量表的容量以变量槽为单位，虚拟机规范没有明确指出一个变量槽应该占用的内存空间大小，只是导向的说每个变量槽都应该能存放一个`boolean`、`byte`、`char`、`short`、`int`、`float`、`reference`、`returnAddress`类型的数据。

对于64位的数据，`long`和`double`会被分配两个连续的变量槽空间，这与`long`和`double`的非原子协定：允许把一次`long`和`double`数据类型读写分为两次32位读写的做法类似。

#### reference
一个对象的引用，虚拟机规范没有固定长度和结构，只规定了功能：
1. 根据引用可以直接或者间接的查找到对象在Java堆中的数据地址或者索引
2. 根据引用查找到对象所属数据类型在方法区中存储的类型信息

#### returnAddress
目前已经很少见了，是为`jsr`，`jsr_w`，`ret`服务的，指向了一条字节码指令的地址，曾经有虚拟机用这些指令处理异常跳转，现在改为采用异常表实现了

虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0到局部变量表的最大变量槽数量。如果访问32位数据，索引`N`就代表使用了第`N`个变量槽，如果访问64位数据，索引`N`就代表了使用第`N`和`N+1`个变量槽。

当一个方法被调用时，虚拟机使用局部变量表来完成实参到形参的传递。如果是实例方法，第0位索引的变量槽默认是方法所属对象实例的引用，也就是`this`。

为了节省栈帧耗费的内存，变量槽是可以重用的，方法体中的变量作用域并不一定覆盖了整个方法体，如果当前字节码PC计数器超出了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来使用。这样会对垃圾收集行为有一些影响。当某些变量离开他的作用域，如果变量槽没有被其他变量重用，那么这个变量就不会被收集，因为局部变量表还存着他的引用，虽然以后这个变量以后也不会再使用了，所以给变量赋值为`null`来帮助`GC`的行为是可以理解的，但是实际上将变量设置为`null`的行为很可能被编译优化当作无效操作消除掉。

注意局部变量不会赋默认值，下面的代码不能运行：
```java
public static void main(String[] args) {
	int a;
	System.out.println(a);
}
```

### 操作数栈
最大深度也在编译的时候被写入到Code属性的`max_stacks`数据项之中，操作数栈中的每一个元素都可以是包括`long`和`double`的任意Java数据类型。

当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令进行入栈出栈的动作来帮助运算，或者调用其他方法的时候利用操作数栈来进行方法参数的传递。概念模型中两个不同的栈帧作为不同方法的虚拟机栈的元素是完全独立的，但是大多数虚拟机的实现会让栈帧出现一部分重叠，让下面栈帧的部分操作数栈和上面栈帧的部分局部变量表重叠在一起，可以节约空间并且减少额外的参数复制传递。
![[Pasted image 20220509220538.png]]


### 动态连接
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，这个引用为了支持方法调用中的动态连接。字节码中的方法调用指令就以常量池里指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候转化为直接引用，这叫静态解析。有一部分符号引用将在每一次运行期间转化为直接引用，这部分就叫动态连接。

### 方法返回地址
两种方式退出方法：
1. 执行引擎遇到任意一个方法返回的字节码指令，即正常调用完成
2. 方法执行过程中遇到了异常，而且这个异常在方法体内没有处理妥当，即异常调用完成
	- 没有返回值

方法退出之后，必须返回到最初方法被调用时的位置。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复他的上层主调方法的执行状态。
1. 方法正常退出时：主调方法的PC计数器的值可以作为返回地址
2. 方法异常退出时，返回地址要通过异常处理表来确定

方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作：
1. 回复上层方法的局部变量表和操作数栈
2. 把返回值压入调用者栈帧的操作数栈中
3. 调整PC计数器的值来指向方法调用指令后面的一条指令

### 附加信息
Java虚拟机规范允许虚拟机实现一些规范里没有描述的信息到栈帧，取决于实现

## 方法调用
方法调用不等于方法中的代码被执行，唯一的任务是确定被调用方法的版本。一切方法调用在Class文件中储存的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。这个方法给Java带来了更强大的动态扩展能力，但是Java的方法调用更复杂。

### 解析
所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分符号引用转化为直接引用。前提是：**方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期不可改变**。也就是说调用目标在编译器进行编译的时候已经确定下来。主要有静态方法和私有方法两大类。

调用不同的方法，有五种方法调用字节码指令：
1. `invokestatic`：调用静态方法
2. `invokespecial`：调用实例构造器`<init>()`方法，私有方法和父类方法
3. `invokevirtual`：调用虚方法
4. `invokeinterface`：调用接口方法，运行时确定一个实现该接口的对象
5. `invokedynamic`：先在运行时动态解析出调用点限定符所引用的方法，然后再执行

前四个调用指令的分派逻辑固化在Java虚拟机内部，最后一个指令的分派逻辑是由用户设定的引导方法决定的。

只要能被`invokestatic`和`invokespecial`指令调用的方法都可以在解析阶段确定唯一的版本
1. 静态方法
2. 私有方法
3. 实例构造器
4. 父类方法
5. final修饰的方法：`invokevirtual`调用，历史原因

这些方法被称为非虚方法，其他方法被称为虚方法。

### 分派
Java是面向对象的程序语言，分派调用揭示了多态性特征的一些最基本的实现，比如重载和重写

#### 静态分派
`Method Overload Resolution`，应该属于解析的一部分。
1. 静态类型、外观类型：引用的类型
2. 实际类型、运行时类型：对象的实际类型

静态分派指的是根据静态类型来决定方法执行版本的分派动作。最典型应用表现就是方法重载，他发正在编译阶段，实际上不是虚拟机来执行的分派，是编译器来确定的，编译器会挑选最合适的。
```java
public class Overload {
	public static void sayHello(int arg) {
		System.out.println("hello int");
	}
	public static void sayHello(char arg) {
		System.out.println("hello long");
	}

	public static void main(String[] args) {
		sayHello('a');
	}
}
```
#### 动态分派
在动态分派中，选择调用方法的版本是根据实际类型决定的，最典型的就是多态，可以用父类的引用调用子类的方法。
```bash
aload
invokevirtual
```
`aload`指令把对象A的引用压入栈顶，对象A是要执行方法的所有者，称为接收者。`invokevirtual`
指令是方法调用指令，他的运行时解析过程大概分为以下几步：
1. 找到操作数栈栈顶的第一个元素所指对象的实际类型，记作C
2. 在C中找到与常量中的描述符和简单名称都相符的方法，
	- 权限校验，通过返回
	- 没通过返回`IllegalAccessError`
3. 没找到，按继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程
4. 最后没找到，抛出`AbstractMethodError`

正是因为`invokevirtual`指令的第一步是在运行期确定接受者的实际类型，所以会根据接受者的实际类型来选择方法版本。这也说明类的字段是没有多态的，当子类声明了与父类同名的字段时，子类的字段会遮蔽父类的同名字段。

#### 单分派和多分派
方法的接受者与方法的参数统称为方法的宗量。根据分派基于多少种宗量可以将分派划分为单分派和多分派两种。
1. 单分派：根据一个宗量对目标方法进行选择
2. 多分派：根据多于一个宗量对目标方法进行选择

Java虚拟机的静态分派属于多分派类型，会根据静态类型和方法参数两个宗量进行选择。动态分配的过程中，目标方法的签名已经在编译期决定了，只需要根据接受者的实际类型选择方法，所以动态分派是单分派类型。

```java
public class Dispatcher {
    static class QQ {}
    static class _360 {}

    public static class Father {
        public void hardChoice(QQ arg) {
            System.out.println("father choose QQ");
        }

        public void hardChoice(_360 arg) {
            System.out.println("father choose _360");
        }
    }

    public static class Son extends Father {
        @Override
        public void hardChoice(QQ arg) {
            System.out.println("son choose QQ");
        }

        @Override
        public void hardChoice(_360 arg) {
            System.out.println("son choose 360");
        }
    }

    public static void main(String[] args) {
        Father father = new Father();
        Father son = new Son();
        father.hardChoice(new _360());
        son.hardChoice(new QQ());
    }
}
```

```bash
public static void main(java.lang.String[]);
  Code:
   Stack=3, Locals=3, Args_size=1
   0:   new             #2; //class Dispatcher$Father
   3:   dup
   4:   invokespecial   #3; //Method Dispatcher$Father."<init>":()V
   7:   astore_1
   8:   new             #4; //class Dispatcher$Son
   11:  dup
   12:  invokespecial   #5; //Method Dispatcher$Son."<init>":()V
   15:  astore_2
   16:  aload_1
   17:  new             #6; //class Dispatcher$_360
   20:  dup
   21:  invokespecial   #7; //Method Dispatcher$_360."<init>":()V
   24:  invokevirtual   #8; //Method Dispatcher$Father.hardChoice:(LDispatcher$_360;)V
   27:  aload_2
   28:  new             #9; //class Dispatcher$QQ
   31:  dup
   32:  invokespecial   #10; //Method Dispatcher$QQ."<init>":()V
   35:  invokevirtual   #11; //Method Dispatcher$Father.hardChoice:(LDispatcher$QQ;)V
   38:  return
```
方法分派的步骤如下：
1. 静态分派：编译时
	1. 确定方法接收者，变量的静态类型是Father，在class文件中写Father类方法的符号引用
	2. 对于方法参数，按照静态类型匹配的原则，找到各自的方法
2. 动态分派：执行时
	- `son.hardChoice(new QQ());`：发现son的实际类型是Son，会调用Son类中的方法
	- `father.hardChoice(new _360());`：father的实际类型就是Father

#### 动态分派的实现
具体的实现可能在各种虚拟机之前会有一些差别。

动态分派执行非常频繁，方法版本的选择过程需要运行时在接受者类型的方法元数据中搜索合适的目标方法。因此虚拟机一般不会频繁的反复搜索类型元数据，一种常见的优化手段是为类型在方法区中建立一个虚方法表，使用虚方法表来提高性能。

> 1. `Virtual Method Table`：虚方法表
> 2. `Interface Method Table`：接口方法表

虚方法表中存放着各个方法的实际入口地址。
1. 如果某个方法在子类中没有被重写，那子类的虚方法表中的入口地址和父类相同方法的入口地址一致，都指向父类的实现入口。
2. 如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为子类实现版本的入口地址。

具有相同签名的方法，在父类、子类的虚方法表中应当具有一样的索引序号。当类型变换的时候，仅仅需要变更查找的虚方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。

虚方法表一般在类加载的连接阶段初始化，准备了类的变量初始值后，虚拟机会把该类的虚方法表也一同初始化完毕。

还有其他的优化方式
- 类型继承关系分析
- 守护内联
- 内联缓存

## 动态类型语言支持
什么是动态类型语言？关键特征是他的类型检查的主体过程是在运行期而不是编译期进行的。核心特征是：变量无类型而变量值才有类型。

### `java.lang.invoke`包
主要目的是解决单纯靠符号引用来确定调用的目标方法导致的资源压力和性能问题，提供了一种新的动态确定目标方法的机制，称为方法句柄。Java语言之前没有办法把一个函数作为参数进行传递，有了方法句柄之后，就可以拥有类似函数指针或者委托的方法别名这样的工具。
```java
public class MethodHandleTest {

    static class ClassA {
        public void println(String s) {
            System.out.println(s);
        }
    }

    public static MethodHandle getPrintMH(Object receiver) throws Throwable {
        // 
        MethodType mt = MethodType.methodType(void.class, String.class);
        return lookup().findVirtual(receiver.getClass(), "println", 
							        mt).bindTo(receiver);
    }

    public static void main(String[] args) throws Throwable {
        Object obj = System.currentTimeMillis() % 2 == 0 
	        ? System.out : new ClassA();
	    // 无论obj是那个实现类，都能正确调用到println方法
        getPrintMH(obj).invokeExact("HelloWorld!");
    }

}
```