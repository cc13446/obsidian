# 运行时数据区域
![](2.Java内存区域/Pasted%20image%2020220507134623.png)
## 程序计数器
程序计数器是一块较小的内存空间，可以看做当前线程执行字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时通过改变这个计数器来选取下一条指令。程序计数器是线程私有的，可以在切换线程的时候帮助存储正确的执行位置。

如果正在执行的是Java方法，则计数器记录了正在执行的虚拟机字节码的地址，如果是本地方法则为空：`Undefined`。

程序计数器是唯一没有任何`OutOfMemoryError`的区域。

## Java虚拟机栈
Java虚拟机栈也是线程私有的，描述了Java方法执行的线程内存模型。每个方法被执行的时候，Java虚拟机会在虚拟机栈里面押入一个栈帧，用于存储：局部变量表、操作数栈、动态连接、方法出口等信息。方法执行完毕时栈帧出栈。

栈帧的具体结构参考[[8.字节码执行引擎]]

Java虚拟机栈规定了两种异常：
1. `StackOverflowError` ：线程请求分配的栈深度超过 Java 虚拟机栈允许的深度
2. `OutOfMemoryError` ：如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存

## 本地方法栈
Java虚拟机栈为Java方法服务，而本地方法栈为虚拟机用到的本地方法服务。本地方法栈具有和Java虚拟机栈一样的异常。

## Java堆
几乎所有的对象实例及其数组都在堆上分配，但是逃逸分析技术等会将一些对象优化到栈上分配。

Java堆是垃圾回收器管理的内存区域，但是并不是所有的Java虚拟机都采用了分代垃圾回收，所以并不能把Java堆分为新生代、老年代、永久代。

从分配内存的角度来看，Java堆中可以划分出很多线程私有的分配缓冲区`TLAB`，这样可以提升分配对象的效率。由于堆区是线程共享的，任何线程都可以访问到堆区中的共享数据，而且对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。所以JVM会先使用`TLAB`内存区域分配对象，在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在堆空间中分配内存。

Java堆可以存在物理上不连续的空间中，但是在逻辑上应该视为连续的。堆可以被实现成固定大小的或者可扩展的，如果在堆中没有完成对象分配，堆也没法再次扩展的时候，Java虚拟机会抛出`OutOfMemoryError`。

### 逃逸分析
逃逸分析`Escape Analysis`是目前 Java 虚拟机中比较前沿的优化技术。这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

逃逸分析的基本行为就是分析对象动态作用域：
-   当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
-   当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。

使用逃逸分析，编译器可以对代码做优化：
-   栈上分配：将堆分配转化为栈分配。
-   同步省略：如果一个对象被发现只能从一个线程被访问到就可以不考虑同步(锁消除)
-   分离对象或标量替换：有的对象不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分或全部可以不存储在内存，而存储在 CPU 寄存器

## 方法区
方法区`Method Area`与 Java 堆一样，是所有线程共享的内存区域，用来存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 `Non-Heap`，目的是与 Java 堆区分开。

永久代和元空间都可以理解为方法区的落地实现。永久代物理是堆的一部分，和新生代，老年代地址是连续的，并且受垃圾回收器管理，这样省去了为方法区编写内存管理代码，但是会让Java程序更容易遇到内存溢出的问题。而且有些方法会因为永久代的存在导致在`HotSpot`虚拟机和其他没有永久代的虚拟机上的表现不一致。

元空间存在于本地内存，不受垃圾回收器管理，也不受 JVM 限制，也比较难发生溢出异常，只要不触碰进程可用内存的上限就没有问题。

对于`HotSpot`虚拟机的方法区，Java8 之后的变化：
-   移除了永久代，替换为元空间
-   永久代中的字符串常量池和静态变量转移到了Java堆
-   永久代中的类信息等转移到了本地内存，即元空间

方法区无法满足新的内存分配需求的时候，Java虚拟机会抛出`OutOfMemoryError`。

### 运行时常量池
运行时常量池是方法区的一部分，Class文件中有一项信息是常量池表，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后会放到运行时常量池。运行期间也可以在池里放新的常量，比如`String`类的`intern()`方法。

## 直接内存
直接内存并不是虚拟机运行时数据区的一部分。Java NIO中的通道和缓冲区可以用本地函数库直接分配堆外内存，然后通过一个存在Java堆里面的`DirectByteBuffer`对象作为这块内存的引用来操作，可以避免来回复制数据，提高性能。


# 对象探秘
## 对象的创建
1. Java虚拟机遇到了一个字节码`new`指令
2. 检查参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否加载、解析和初始化过。没有就要先执行类的加载过程。
3. 类加载之后，对象所需的内存大小就可以确定，虚拟机要为新生对象分配内存。
	- 指针碰撞：堆中内存规整，将分界指针向空闲空间的方向移动即可。
	- 空闲列表：堆中内存不规整，需要在虚拟机维护的空闲列表中查找足够的联系空间。
4. 分配内存的时候还需要考虑同步问题
	- 采取CAS加自旋的方式保证内存分配的原子性
	- 在内存线程分配缓冲`TLAB`中进行分配
5. 将分配到的内存初始化为零值
6. 对对象进行必要的设置：设置对象的对象头`Object Header`
7. 此时从虚拟机的视角一个新的对象已经产生了，开始执行构造函数。

## 对象的内存布局
在`HotSpot`虚拟机中，对象在堆内存的存储布局可以分为三个部分
1. 对象头
	- `MarkWord`
	- 类型指针，即对象指向它的类型元数据的指针
	- 如果对象是数组，还要有一块用来记录长度的数据
2. 实例数据：程序代码里面定义的各种类型的字段，包括父类和子类自身的
3. 对齐填充

### MarkWord
![[Pasted image 20220507155643.png]]

## 对象的访问定位
Java程序通过栈上的引用数据来操作堆上的具体对象。Java虚拟机规范并没有规定怎么去实现这个引用，主流的方式有两种：
1. 句柄：Java堆中划分一块内存作为句柄池，栈中储存对象的句柄地址，而句柄中包含了对象实例数据与类型数据的指针，对象移动的时候只需要改动句柄。
2. 直接指针：直接存储对象的地址，少一次访问的开销。

### 句柄
![[Pasted image 20220507161438.png]]
### 直接指针
![[Pasted image 20220507161705.png]]