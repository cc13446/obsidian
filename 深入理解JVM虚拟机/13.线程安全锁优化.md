# 线程安全和锁优化
线程安全定义：多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行文都可以获得正确的结果，就说这个对象是线程安全的

把定义弱化：把调用这个对象的行为限定为单词调用

## 线程安全
### Java线程安全
#### 1. 不可变
不可变的类型
1. `final` 关键字修饰的基本数据类型
2. `String`
3. 枚举类型
4. `Number` 部分子类
	- 如 `Long` 和 `Double` 等数值包装类型，`BigInteger` 和 `BigDecimal` 等大数据类型
	- 但同为 `Number` 的原子类 `AtomicInteger` 和 `AtomicLong` 则是可变的。
5. `Collections.unmodifiableXXX()`方法修饰的集合

#### 2.  绝对线程安全
不管运行时环境如何，调用者都不需要任何额外的同步措施。

#### 3. 相对线程安全
相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。 在 Java 语言中，大部分的线程安全类都属于这种类型
1. `Vector`
2. `ConcurrentHashTable`
3. `synchronizedCollection()` 方法包装的集合

#### 4. 线程兼容
线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。

#### 5. 线程对立
线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。

### 线程安全的实现方法
#### 互斥同步
同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只能被一条线程使用，而互斥是实现同步的一种手段。临界区、互斥量、信号量都是常见的互斥实现方式。

最基本的互斥同步手段就是`synchronized`关键字，这是一块结构的同步语法。经过Javac编译之后，会在同步块的前后分别形成`monitorenter`和`monitorexit`这两个字节码指令。这两个字节码指令都需要一个`reference`类型的参数来指明要锁定和解锁的对象。如果`synchronized`关键字指定了对象参数，就以这个对象作为`reference`，如果没有明确指定，那就根据`synchronized`关键字修饰的方法类型来决定是取代码的对象实例还是类对象Class。

根据虚拟机规范的要求，执行`monitorenter`指令的时候，首先尝试获取对象的锁，如果对象没被锁定，或者当前线程已经持有了那个对象的锁，那就把锁的计数器+1。`monitorexit`则会将当前锁的计数器-1。计数器的值为0，锁就被释放了。获取对象锁失败，当前线程被阻塞等待。

可以得出`synchronized`关键字的两个特性：
1. 可重入
2. 无法强制已获取锁的线程释放锁，也无法强制正在等待锁的线程中断等待或者超时推出

Java语言还提供了`Lock`接口，用户可以以非块结构来实现互斥同步。`ReentrantLock`是`Lock`接口的一种常见的实现。三项功能：
1. 等待可中断：正在等待的线程可以放弃等待
2. 公平锁
3. 锁绑定多个条件

#### 非阻塞同步
互斥同步面临的主要问题是进行线程阻塞和唤醒带来的性能开销，所以又叫阻塞同步，属于一种悲观的并发策略。我们可以选择**基于冲突检测的乐观并发策略**，也就是不管风险，先操作，如果没有线程争用共享数据那操作就直接成功了，如果线程有争用就在进行其他的补偿措施，一般来说都是不断重试。

常用的原子性指令有：
1. `Test and Set`
2. `Fetch and Increment`
3. `Swap`
4. `Compare and Swap, CAS`
5. `Load-Linked/Store-Conditional, LL/SC`

#### 无同步方案
1. 可重入代码
2. 线程本地存储
3. 栈封闭：栈中的变量为线程私有 




