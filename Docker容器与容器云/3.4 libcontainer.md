## libcontainer 工作方式
`execdriver`需要借助`libcontainer`处理以下事情
1. 创建`libcontainer`构建容器需要使用的进程对象，称为Process
2. 设置容器的输出管道，这里使用的就是daemon提供的pipes
3. 使用名为Factory的工厂类，通过`factory.Create(<容器ID>, <容器配置container>)`创建一个逻辑上的容器，称为Container，容器配置会填充到Container对象的config中
4. 执行`Container.Start(Process)`启动物理的容器
5. `execdriver`执行由Docker daemon提供的startCallback完成回调动作
6. `execdriver`执行`Process.Wait`，一直等上述Process的所有工作都完成

libcontainer对容器做了一层更高级的抽象，它定义了Process和Container来对应Linux中进程和容器的关系。一旦物理的容器创建成功，其他调用者就可以通过容器ID获取这个逻辑容器Container，接着使用`Container.Stats`得到容器的资源使用信息，或者执行`Container.Destory`来销毁这个容器。

libcontainer主要内容是Process、Container以及Factory这三个逻辑实体的实现原理，而execdriver或者其他调用者只要依次执行以下操作就可以创建容器
1. 使用Factory创建逻辑容器Container
2. 启动逻辑容器Container
3. 用逻辑容器创造物理容器

## libcontainer 实现原理
### 使用Factory创建逻辑容器Container
逻辑容器并不是一个运行着的Docker容器，而是包含了容器要运行的指令及其参数、namespace配置和cgroups配置参数等。由于需要跟底层系统打交道，不同的平台就需要创建出完全异构的逻辑容器对象，这就解释了为什么要使用工厂模式。

Factory的Create操作具体做的事情有：
1. 验证容器运行的根目录、容器ID和容器配置这三项内容的合法性
2. 验证上述容器ID与现有的容器不冲突
3. 在根目录下创建以ID为名的容器工作目录
4. 返回Container对象：容器ID、容器工作目录、容器配置、初始化指令和参数、cgroups管理器

### 启动逻辑容器Container
参与物理容器创建过程的Process一共有两个实例，第一个叫Process，用于物理容器内进程的配置和IO的管理，另一个叫ParentProcess，负责从物理容器外部处理物理容器启动工作，与Container对象直接进行交互。启动工作完成后，ParentProcess负责执行等待、发信号、获得容器内进程PID等管理工作。

创建ParentProcess的过程如下：
1. 创建一个管道，用来与容器内未来要运行的进程通信
2. 根据逻辑容器中与容器内未来要运行的进程相关的信息创建一个容器内进程启动命令cmd对象
