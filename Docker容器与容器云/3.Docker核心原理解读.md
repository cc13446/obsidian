## Docker 背后的内核知识
### namespace 资源隔离
`namespace` 是 `Linux` 内核用来隔离内核资源的方式。通过 `namespace` 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。

通过将系统的全局资源放在不同的`namespace`中，可以实现资源隔离的目的。不同`namespace`的程序，可以享有一份独立的系统资源。目前Linux中提供了六类系统资源的隔离机制，分别是：
1. `Mount`: 隔离文件系统挂载点
2. `UTS`: 隔离主机名和域名信息
3. `IPC`: 隔离进程间通信
4. `PID`: 隔离进程的ID
5. `Network`: 隔离网络资源
6. `User`: 隔离用户和用户组

为了使用特定的`Namespace`，在使用一些接口的时候需要指定以下一个或多个参数：
1. `CLONE_NEWNS`: 用于指定`Mount Namespace`
2. `CLONE_NEWUTS`: 用于指定`UTS Namespace`
3. `CLONE_NEWIPC`: 用于指定`IPC Namespace`
4. `CLONE_NEWPID`: 用于指定`PID Namespace`
5. `CLONE_NEWNET`: 用于指定`Network Namespace`
6. `CLONE_NEWUSER`: 用于指定`User Namespace`

下面是通过`namespace API`操作的四种方式，为了确定隔离的到底是6项`namespace`中的哪几项，在使用这些API时，通常需要执行以上六个参数的一个或者多个，并通过位或操作来实现。

#### 1. clone 函数
创建新进程的同时创建`namespace`，这是最常见的做法，也是Docker最基本的方法
```c
int clone(int (*child_func)(void *), void *child_stack, int flags, void *arg);
```

实际上`clone()`函数是Linux系统调用`fork()`的一种更通用的实现方式，他可以通过`flags`来控制使用多少功能。下面对与`namespace`相关的四个参数进行说明：
1. `child_func`：传入子进程运行的程序主函数
2. `child_stack`：传入子进程使用的栈空间
3. `flags`：标志位，可以位或`CLONE_NEWUTS`等做资源隔离
4. `aegs`：传入用户参数

#### 2. setns 函数
可以把进程加入到已经存在的`Namespace`中，在Docker中，使用`docker exec`命令在已经运行着的容器中执行一个新的命令，就需要用到该方法。通常为了不影响进程的调用者，也为了使新加入的`pid namespace`生效，会在`setns`函数执行后使用`clone`创建紫禁城继续执行命令，让原先的进程结束。

```c
int setns(int fd, int nstype);
```

它的参数描述如下：
1. `fd`：指向`/proc/[pid]/ns`目录的文件描述符
2. `nstype`：用来检查`fd`关联`namespace`是否符合实际要求，参数为0则不检查

为了把新加入的`namespace`利用起来，需要引入`execve`系列函数

```c
fd = open(argv[1], O_RDONLY); // 打开namespace文件描述符
setns(fd, 0);                 // 加入新的namespace
execvp(argv[2], &argv[2]);    // 执行程序
```

这样就可以在新加入的`namespace`中执行shell命令了

```bash
./setns-test ~/mnt /bin/bash # ~/mnt 是绑定的/proc/133410/ns/mnt
```

#### 3. unshare 函数
用于将当前进程和所在的`Namespace`分离，并加入到一个新的`Namespace`中，相对于`setns()`系统调用来说，`unshare()`不用关联之前存在的`Namespace`，只需要指定需要分离的`Namespace`就行，该调用会自动创建一个新的`namespace`。

```c
int unshare(int flags);
```

其中`flags`用于指明要分离的资源类别，它支持的`flags`与`clone`系统调用支持的`flags`类似，这里简要的叙述一下几种标志：
1. `CLONE_FILES`: 子进程默认共享父进程的文件描述符，此标志取消对父进程的文件描述符的共享
2. `CLONE_FS`: 使当前进程不再与其他进程共享文件系统信息
3. `CLONE_SYSVSEM`: 取消与其他进程共享`SYS V`信号量
4. `CLONE_NEWIPC`: 创建新的`IPC Namespace`，并将该进程加入进来

#### 4. 通过/proc文件查看已存在的Namespace
在3.8内核开始，用户可以在`/proc/$pid/ns`文件下看到本进程所属的`Namespace`的文件信息。

```bash
$ ls -al /proc/133410/ns/
total 0
dr-x--x--x 2 cc cc 0 Jul 27 18:48 .
dr-xr-xr-x 9 cc cc 0 Jul 27 18:14 ..
lrwxrwxrwx 1 cc cc 0 Jul 27 18:48 cgroup -> cgroup:[4026531835]
lrwxrwxrwx 1 cc cc 0 Jul 27 18:48 ipc -> ipc:[4026531839]
lrwxrwxrwx 1 cc cc 0 Jul 27 18:48 mnt -> mnt:[4026531840]
lrwxrwxrwx 1 cc cc 0 Jul 27 18:48 net -> net:[4026531992]
lrwxrwxrwx 1 cc cc 0 Jul 27 18:48 pid -> pid:[4026531836]
lrwxrwxrwx 1 cc cc 0 Jul 28 11:46 pid_for_children -> pid:[4026531836]
lrwxrwxrwx 1 cc cc 0 Jul 27 18:48 user -> user:[4026531837]
lrwxrwxrwx 1 cc cc 0 Jul 27 18:48 uts -> uts:[4026531838]
```

其中 `4026531835` 表明是`namespace`的ID，如果两个进程的`namespace` ID相同表明两个进程同处于一个命名空间中。只要`/proc/$pid/ns/`对应的`namespace`文件被打开，并且该文件描述符存在，那么就算该`namespace`下所有进程都已经结束，这个`namespace`会依然存在，后续进程也可以再加入进来。在Docker中，通过文件描述符定位和加入一个存在的`namespace`是最基本的方式。

可以通过挂载的方式打开文件描述符：

```bash
touch ~/mnt
mount --bind /proc/133410/ns/mnt ~/mnt
```

这样就可以保留住`PID`为`133410`的进程的`Mount Namespace`了，即使`133410`进程被销毁或者退出，ID为`4026531835`的`Mount Namespace`依然会存在。

