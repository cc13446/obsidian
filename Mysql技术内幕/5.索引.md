## InnoDB存储引擎索引概述
InnoDB存储引擎支持以下几种常见的索引：
1. B+树索引
2. 全文索引
3. 哈希索引：自适应，根据使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成

B+树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据。

## B+树索引
B+索引在数据库中有一个特点是高扇出性，因此在数据库中，B+树的高度一般都在2到4层，这也就是说查找某一键值的行记录时最多只需要2到4次IO。

数据库中的B+树索引可以分为聚集索引和辅助索引，但是不管是聚集还是辅助的索引，其内部都是B+树，即高度平衡的，叶子节点存放着所有的数据。聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息。

### 聚集索引
InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放。而聚集索引就是按照每张表的主键构造一颗B+树。叶子节点中存放表的所有行记录数据，所以聚集索引的叶子节点也就是数据页。所以在索引组织表中，数据也是索引的一部分，每个数据页都通过一个双向链表来进行连接。

每张表只能有一个聚集索引。大多数情况下查询优化器会采用聚集索引，因为聚集索引能直接在叶子节点拿到数据，而且聚集索引在逻辑上对数据进行了排序，所以可以进行针对范围值的查询，对于根据主键的排序请求也不需要特殊处理。

聚集索引的存储并不是物理上连续的，而是逻辑上连续的。这其中有两点：
1. 页通过双向链表链接，页按照主键的顺序排序
2. 另一点是每个页中的记录也是通过链表进行维护的，物理存储上可以同样不按照主键存储

### 辅助索引
对于辅助索引，叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签。该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。

每张表上可以有多个辅助索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。

### B+树索引的分裂
InnoDB存储引擎的`Page Header`中有以下几个部分用来保存插入的顺序信息：
1. `PAGE_LAST_INSERT`
2. `PAGE_DIRECTION`
3. `PAGE_N_DIRECTION`

通过这些信息，InnoDB存储引擎可以决定是向左还是向右进行分裂，同时决定将分裂点记录为哪一个。若插入是随机的，则取页的中间记录作为分裂点的记录。若往同一方向进行插入的记录数量为5，并且目前已经定位到的记录**待插入记录的前一条记录**，之后还有3条记录，则分裂点的记录为定位到的记录后的第三条记录，否则分裂点记录就是待插入的记录。

#### 向右分裂的例子
向右分裂且定位到的记录之后还有3条记录
![](5.索引/Pasted%20image%2020220516170223.png)
![](5.索引/Pasted%20image%2020220516170335.png)

向右分裂且定位到的记录之后没有3条记录
![](5.索引/Pasted%20image%2020220516170443.png)

## Cardinality值
一般来说，在数据具有高选择性的时候使用B+树索引是最合适的。

怎样查看索引是否是高选择性的呢？可以通过`SHOW INDEX`结果中的列`Cardinality`来观察。

`Cardinality`值表示索引中不重复记录数量的预估值。需要注意的是，`Cardinality`是一个预估值，基本上用户也不可能得到一个准确的值。`Cardinality/n_rows_in_table`应尽可能地接近1。如果非常小，那么用户需要考虑是否还有必要创建这个索引。

### InnoDB存储引擎的Cardinality统计
数据库对于`Cardinality`的统计都是通过采样的方法来完成的

#### Cardinality统计的时机
`Cardinality`统计信息的更新发生在两个操作中：`INSERT`和`UPDATE`。避免增加数据库的负荷，不可能在每次发生`INSERT`和`UPDATE`时就去更新。InnoDB存储引擎内部对更新`Cardinality`信息的策略为：
1. 表中1/16的数据已发生过变化
2. `stat_modified_counter ＞ 2 000 000 000`

第二种情况考虑的是，如果对表中某一行数据频繁地进行更新操作，这时表中的数据实际并没有增加，实际发生变化的还是这一行数据，则第一种更新策略就无法适用这这种情况。

#### Cardinality统计的实现
`InnoDB`存储引擎内部是怎样来进行`Cardinality`信息的统计和更新操作的呢？同样是通过采样的方法。默认InnoDB存储引擎对8个叶子节点进行采用。采样的过程如下：
1. 取得B+树索引中叶子节点的数量，记为A
2. 随机取得B+树索引中的8个叶子节点。统计每个页不同记录的个数：P1，P2，…，P8
3. 根据采样信息给出`Cardinality`的预估值：`Cardinality = (P1+P2+…+P8) * A/8`

#### Cardinality值的特点
1. 在InnoDB存储引擎中，是通过对8个叶子节点预估而得的，不是一个实际精确的值
2. 即每次得到的`Cardinality`值可能是不同的

## B+树索引的使用
### 联合索引
联合索引是指对表上的多个列进行索引。前面讨论的情况都是只对表上的一个列进行索引。联合索引的创建方法与单个索引创建的方法一样，不同之处仅在于有多个索引列。

联合索引也是一棵B+树，不同的是联合索引的键值的数量不是1，而是大于等于2。假定两个键值的名称分别为a、b，索引数据按`(a，b)`的顺序进行了存放。所以查询条件时含有`a`的时候才能使用这个索引，只有`b`的时候不能用。

### 覆盖索引
`InnoDB`存储引擎支持覆盖索引，即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。

### 优化器选择不使用索引的情况
在某些情况下，当执行`EXPLAIN`命令进行SQL语句的分析时，会发现优化器并没有选择索引去查找数据，而是通过扫描聚集索引，也就是直接进行全表的扫描来得到数据。这种情况多发生于范围查找、JOIN链接操作等情况下。

### 索引提示
MySQL数据库支持索引提示，显式地告诉优化器使用哪个索引。个人总结以下两种情况可能需要用到`INDEX HINT`：
1. MySQL数据库的优化器错误地选择了某个索引，导致SQL语句运行的很慢
2. 可以选择的索引非常多，这时优化器选择执行计划时间的开销可能会大于SQL语句本身

### Multi-Range Read优化
`MySQL5.6`版本开始支持`Multi-Range Read`优化，目的就是为了减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，这对于IO-bound类型的SQL查询语句可带来性能极大的提升。`Multi-Range Read`优化可适用于`range`，`ref`，`eq_ref`类型的查询。

MRR优化有以下几个好处：
1. 使数据访问变得较为顺序
	- 查询辅助索引后根据得到的查询结果按照主键进行排序，并按照主键排序顺序进行书签查找
2. 减少缓冲池中页被替换的次数
3. 批量处理对键值的查询操作

对于`InnoDB`和`MyISAM`存储引擎的范围查询和`JOIN`查询操作，MRR的工作方式如下：
1. 将查询得到的辅助索引键值存放于一个缓存中，这时缓存中的数据是根据辅助索引键值排序的
2. 将缓存中的键值根据RowID进行排序
3. 根据RowID的排序顺序来访问实际的数据文件

此外，若InnoDB存储引擎或者MyISAM存储引擎的缓冲池不是足够大，即不能存放下一张表中的所有数据，此时频繁的离散读操作还会导致缓存中的页被替换出缓冲池，然后又不断地被读入缓冲池。若是按照主键顺序进行访问，则可以将此重复行为降为最低。

### Index Condition Pushdown优化
之前当进行索引查询时，首先根据索引来查找记录，然后再根据`WHERE`条件来过滤记录。

在支持`Index Condition Pushdown`后，MySQL数据库会在取出索引的同时，判断是否可以进行`WHERE`条件的过滤，也就是将`WHERE`的部分过滤操作放在了存储引擎层。在某些查询下，可以大大减少上层SQL层对记录的索取，从而提高数据库的整体性能。

## 哈希算法
### InnoDB存储引擎中的哈希算法
`InnoDB`存储引擎使用哈希算法来对字典进行查找，其冲突机制采用链表方式，哈希函数采用除法散列方式。
1. 在缓冲池中的`Page`页都有一个`chain`指针指向相同哈希函数值的页
2. 哈希槽的取值为略大于2倍的缓冲池页数量的质数

那么InnoDB存储引擎的缓冲池对于其中的页是怎么进行查找的呢？

其实也很简单，`InnoDB`存储引擎的表空间都有一个`space_id`，用户所要查询的应该是某个表空间的某个连续16KB的页，即偏移量`offset`。`InnoDB`存储引擎将`space_id`左移20位，然后加上这个`space_id`和`offset`，即关键字`K = space_id ＜＜ 20 + space_id + offset`，然后通过除法散列到各个槽中去。

### 自适应哈希索引
自适应哈希索引采用链式哈希表的方式实现。不同的是，这仅是数据库自身创建并使用的，DBA本身并不能对其进行干预。自适应哈希索引经哈希函数映射到一个哈希表中，因此对于字典类型的查找非常快速，但是对于范围查找就无能为力了。


## 全文检索
很多的情况下，用户需要查询的是博客内容包含单词xxx的文章，即：
```sql
SELECT*FROM blog WHERE content like'%xxx%'
```

全文检索是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。它可以根据需要获得全文中有关章、节、段、句、词等信息，也可以进行各种统计和分析。

从`InnoDB 1.2.x`版本开始，`InnoDB`存储引擎开始支持全文检索，其支持`MyISAM`存储引擎的全部功能，并且还支持其他的一些特性。

### 倒排索引
全文检索通常使用倒排索引来实现。倒排索引同B+树索引一样，也是一种索引结构。它在辅助表中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。这通常利用关联数组实现，其拥有两种表现形式：
1. `inverted file index`：其表现形式为`{单词, 单词所在文档的ID}`
2. `full invertedindex`：其表现形式为`{单词, (单词所在文档的ID，在具体文档中的位置)}`

### InnoDB全文检索
`InnoDB`存储引擎从`1.2.x`版本开始支持全文检索的技术，其采用`full inverted index`的方式，将`(DocumentId，Position)`视为一个`ilist`。因此在全文检索的表中，有两个列，一个是`word`字段，另一个是`ilist`字段，并且在`word`字段上设有索引。

当前InnoDB存储引擎的全文检索还存在以下的限制：
1. 每张表只能有一个全文检索的索引
2. 由多列组合而成的全文检索的索引列必须使用相同的字符集与排序规则
3. 不支持没有单词界定符的语言，如中文、日语、韩语等

#### Auxiliary Table
倒排索引需要将`word`存放到一张表中，这个表称为`Auxiliary Table`。为了提高全文检索的并行性能，共有6张`Auxiliary Table`，每张表根据`word`的`Latin`编码进行分区。`Auxiliary Table`是持久的表，存放于磁盘上。

#### FTS Index Cache
在`InnoDB`存储引擎全文索引中，还有另外一个重要的概念全文检索索引缓存`FTS Index Cache`，其用来提高全文检索的性能，这是一个红黑树结构，其根据`(word，ilist)`进行排序。这意味着插入的数据已经更新了对应的表，但是对全文索引的更新可能在分词操作之后还在`FTS Index Cache`中，`Auxiliary Table`可能还没有更新。`InnoDB`存储引擎会批量对`Auxiliary Table`进行更新，而不是每次插入后更新一次`Auxiliary Table`。

当对全文检索进行查询时，`Auxiliary Table`首先会将在`FTS Index Cache`中对应的`word`字段合并到`Auxiliary Table`中，然后再进行查询。这种合并操作非常类似之前介绍的`Insert Buffer`的功能，不同的是`Insert Buffer`是一个持久的对象，并且其是B+树的结构。

对于`InnoDB`存储引擎而言，倒排索引总是在事务提交时将分词写入到`FTS Index Cache`，然后再通过批量更新写入到磁盘。虽然InnoDB存储引擎通过一种延时的、批量的写入方式来提高数据库的性能，但是上述操作仅在事务提交时发生。

当数据库关闭时，在`FTS Index Cache`中的数据库会同步到磁盘上的`Auxiliary Table`中。然而，如果当数据库发生宕机时，一些`FTS Index Cache`中的数据库可能未被同步到磁盘上。那么下次重启数据库时，当用户对表进行全文检索时，`InnoDB`存储引擎会自动读取未完成的文档，然后进行分词操作，再将分词的结果放入到`FTS Index Cache`中。

#### FTS Document ID
`FTS Document ID`是另外一个重要的概念。为了支持全文检索，必须有一个列与`word`进行映射，在`InnoDB`中这个列被命名为`FTS_DOC_ID`，其类型必须是`BIGINT UNSIGNED NOT NULL`，并且会自动在该列上加入一个名为`FTS_DOC_ID_INDEX`的`Unique Index`。

#### DELETED auxiliary table
文档中分词的插入操作是在事务提交时完成，然而对于删除操作，其在事务提交时，不删除磁盘`Auxiliary Table`中的记录，而只是删除`FTS Cache Index`中的记录。对于`Auxiliary Table`中被删除的记录，`InnoDB`存储引擎会记录其`FTS Document ID`，并将其保存在`DELETED auxiliary table`中。由于文档的`DML`操作实际并不删除索引中的数据，相反还会在对应的`DELETED`表中插入记录，因此随着应用程序的允许，索引会变得非常大。为此，`InnoDB`存储引擎提供了一种方式，允许用户手工地将已经删除的记录从索引中彻底删除，该命令就是`OPTIMIZE TABLE`。

#### stopword
`stopword`列表是本小节最后阐述的一个概念，其表示该列表中的`word`不需要对其进行索引分词操作。`InnoDB`存储引擎有一张默认的`stopword`列表，其在`information_schema`架构下，表名为`INNODB_FT_DEFAULT_STOPWORD`，默认共有36个`stopword`。此外用户也可以通过参数`innodb_ft_server_stopword_table`来自定义`stopword`列表。

