# 锁
## lock和latch
`latch`：目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制
`lock`：对象是事务，用来锁定的是数据库中的对象，如表、页、行。

## InnoDB存储引擎中的锁
### 锁的类型
`InnoDB`实现了如下两种标准的锁：
- 共享锁`S Lock`：允许事务读数据
- 排他锁`X Lock`：允许事务删除或更新数据

两种锁的兼容性如下表：
![](6.锁/Pasted%20image%2020220517103417.png)

此外，InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，它支持一种额外的锁方式，称之为意向锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。
![](6.锁/Pasted%20image%2020220517100538.png)

InnoDB存储引擎的意向锁的设计目的主要是为了在一个事务中揭示上层对象中下层对象将被请求的锁类型。其支持两种意向锁：
1. 意向共享锁`IS Lock`：事务想要获得一张表中某几行的共享锁
2. 意向排他锁`IX Lock`：事务想要获得一张表中某几行的排他锁

将上锁的对象看成一棵树，对下层的对象上锁，首先需要对粗粒度的对象上锁。意向锁的兼容性如下表所示，注意这里的共享锁和排它锁指的是在意向锁同一个对象上加的锁。
![](6.锁/Pasted%20image%2020220517100816.png)

引进意向锁后，系统对某一数据对象加锁时不必逐个检查与下一级结点的封锁冲突了。例如，事务 `T` 要对表 `R` 加 `X` 锁时，系统只要检查 `R` 本身是否已加了不相容的锁，而不再需要搜索和检查 `R` 中的每一个元组是否加了 `X` 锁或 `S` 锁。

### 一致性非锁定读
一致性的非锁定读指InnoDB存储引擎通过`MVCC`的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行`DELETE`或`UPDATE`操作，这时读取操作不会因此去等待行上锁的释放，而是去读取行的一个快照数据，所以称其为非锁定读。

快照数据是指该行的之前版本的数据，该实现是通过`undo`段来完成。而`undo`用来在事务中回滚数据，因此快照数据本身没有额外的开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。

一致性非锁定读是InnoDB默认的读取方式，但是在不同的事务隔离级别下读取的方式也会不一样。即使使用非一致锁定读对于快照数据的定义也不相同。

InnoDB存储引擎的默认事务隔离级别是`可重复读`。

在`读提交`和`可重复读`的事务隔离级别下，InnoDB存储引擎使用非锁定的一致性读。然而，对于快照数据的定义却不相同。
1. 读提交：非一致性读总是读取被锁定行的最新一份快照数据。
2. 可重复读：非一致性读总是读取事务开始时的行数据版本。

### 一致性锁定读
在某些情况下，用户需要显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。而这要求数据库支持加锁语句，即使是对于`SELECT`的只读操作。`InnoDB`存储引擎对于`SELECT`语句支持两种一致性的锁定读操作：
1. `SELECT … FOR UPDATE`：加一个X锁
2. `SELECT … LOCK IN SHARE MODE`：加一个S锁

注意：一致性锁定读必须在一个事务中，当事务提交了，锁也就释放了。

### 自增长与锁
#### 自增长列的限制
在InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第一个列。如果不是第一个列，则MySQL数据库会抛出异常，而MyISAM存储引擎没有这个问题，

#### AUTO-INC Locking
在`InnoDB`存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器。当对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化。插入操作会依据这个自增长的计数器值加1赋予自增长列，期间会对这个计数器加锁。

这种锁其实是采用一种特殊的表锁机制，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成对自增长值插入的SQL语句后立即释放。但是这种实现方式对于有自增长值的列的并发插入性能较差，事务必须等前一个插入的完成。

#### 新的自增长机制
从`MySQL 5.1.22`版本开始，InnoDB存储引擎中提供了一种轻量级互斥量的自增长实现机制，这种机制大大提高了自增长值插入的性能。

##### 自增长插入分类
1. `insert-like`：所有的插入语句
2. `simple inserts`：插入前就能确定插入行数的语句
3. `bulk inserts`：插入前不能确定得到插入行数的语句
4. `mixed-mode inserts`：插入中有一部分的值是自增长的，有一部分是确定的。

##### innodb_autoinc_lock_mode参数
###### 0：传统模式
使用`AUTO-INC Locking` 方式。

###### 1：连续模式
这是参数的默认值。
1. `simple inserts`：用互斥量对内存中的计数器进行累加，插入N行就加N
2. `bulk inserts`：使用`AUTO-INC Locking` 方式

在这种配置下，如果不考虑回滚的情况，自增长列的值还是连续的。需要注意的是，如果正在使用`AUTO-INC Locking` 方式去产生自增长的的值，再需要进行`simple inserts`的操作时，还需要等待锁的释放。

###### 2：交叉模式
对于所有的插入操作都使用互斥量进行累加。但是这样自增长的值可能就不是连续的了，因为对于并发的插入，`AUTO_INCREMENT`  的值分配会在多个 `INSERT`  语句中来回交叉的执行。

> Binlog 的格式有以下几种：
> 1. `Statement`： 基于语句，只记录对数据做了修改的SQL语句
> 2.  `Row`： 只记录被修改的行
> 3. `Mixed`：`Statement`和`Row`的结合
>	1. 像`alter table`之类的对表结构的修改，采用`Statement`格式。
>	2. 其余的对数据的修改，例如`update` 和`delete`采用`Row`格式进行记录。
>
>如果 MySQL 采用的格式为 `Statement`，那么 MySQL 的主从同步实际上同步的是一条一条的 SQL 语句。如果此时我们采用了交叉模式，那么并发情况下 `INSERT`  语句的执行顺序就无法得到保障。

### 外键和锁
在InnoDB存储引擎中，对于一个外键列，如果没有显式地对这个列加索引，InnoDB存储引擎自动对其加一个索引。

对于外键值的插入或更新，首先需要查询父表中的记录。但是对于父表的`SELECT`操作，不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题，因此这时使用的是`SELECT…LOCK IN SHARE MODE`方式，即主动对父表加一个S锁。如果这时父表上已经这样加X锁，子表上的操作会被阻塞。

## 锁的算法
InnoDB存储引擎有三种行锁的算法：
1. 记录锁`Record Lock`：单个行记录上的锁
2. 间隙锁`Gap Lock`：锁定一个范围，但是不包含记录本身
3. 临键锁`Next-Key Lock`：锁定一个范围和记录本身

当查询的索引含有唯一属性，同时查询是一个点查询时，`InnoDB`存储引擎会对`Next-Key Lock`进行优化，将其降级为`Record Lock`，即仅锁住索引本身，而不是范围。

## 锁问题
### 脏读
脏读指的就是在不同的事务下，当前事务可以读到另外事务未提交的数据，简单来说就是可以读到脏数据。

### 不可重复读
不可重复读是指在一个事务内多次读取同一数据集合。在这个事务还没有结束时，另外一个事务也访问该同一数据集合，并做了一些DML操作。因此，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的情况，这种情况称为不可重复读。

不可重复读和脏读的区别是：脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据，但是其违反了数据库事务一致性的要求。

### 幻读
幻读名如其文，它就像发生了某种幻觉一样，在一个事务中明明没有查到主键为 `X` 的数据，但主键为 `X` 的数据就是插入不进去，就像某种幻觉一样。

不可重复读和幻读的区别：二者描述的则重点不同，不可重复读描述的侧重点是修改操作，而幻读描述的侧重点是添加和删除操作。

#### Mysql在RR级别下解决幻读了么？
从严格意义上说没有解决。根据读取数据方式，可以分为快照读和当前读
1. 在快照读方式下，通过`mvcc` + 间隙锁的方式解决了幻读
2. 在当前读方式下，事务可以 `update` 一条看不见的数据

### 丢失更新
丢失更新是另一个锁导致的问题，简单来说其就是一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。例如：
1. 事务`T1`将行记录`r`更新为`v1`，但是事务`T1`并未提交。
2. 与此同时，事务`T2`将行记录`r`更新为`v2`，事务`T2`未提交。
3. 事务T1提交。
4. 事务T2提交。

在当前数据库的任何隔离级别下，都不会导致数据库理论意义上的丢失更新问题。但是在生产应用中还有另一个逻辑意义的丢失更新问题，而导致该问题的并不是因为数据库本身的问题。实际上，在所有多用户计算机系统环境下都有可能产生这个问题。简单地说来，出现下面的情况时，就会发生丢失更新：
1. 事务T1查询一行数据，放入本地内存，并显示给一个终端用户User1。
2. 事务T2也查询该行数据，并将取得的数据显示给终端用户User2。
3. User1修改这行记录，更新数据库并提交。
4. User2修改这行记录，更新数据库并提交。

显然，这个过程中用户User1的修改更新操作丢失了。可以在查询的时候加上排它锁来解决。

## 阻塞
因为不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源，这就是阻塞。阻塞并不是一件坏事，其是为了确保事务可以并发且正常地运行。

在InnoDB存储引擎中，参数`innodb_lock_wait_timeout`用来控制等待的时间，默认是50秒，`innodb_rollback_on_timeout`用来设定是否在等待超时时对进行中的事务进行回滚操作，默认是OFF，代表不回滚。

## 死锁
死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。若无外力作用，事务都将无法推进下去。解决死锁问题最简单的方式是不要有等待，将任何的等待都转化为回滚，并且事务重新开始。

### 超时机制
解决死锁问题最简单的一种方法是超时，即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。

### 等待图
除了超时机制，当前数据库还都普遍采用等待图的方式来进行死锁检测。较之超时的解决方案，这是一种更为主动的死锁检测方式。InnoDB存储引擎也采用的这种方式。

等待图要求数据库保存以下两种信息：
1. 锁的信息链表
2. 事务等待链表

通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。在等待图中，事务为图中的节点。而在图中，事务T1指向T2边的定义为：
1. 事务T1等待事务T2所占用的资源
2. 事务之间在等待相同的资源，而事务T1发生在事务T2的后面

## 锁升级
锁升级是指将当前锁的粒度降低。举例来说，数据库可以把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁。如果在数据库的设计中认为锁是一种稀有资源，而且想避免锁的开销，那数据库中会频繁出现锁升级现象。

InnoDB存储引擎不存在锁升级的问题。因为其不是根据每个记录来产生行锁的，相反，其根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式。因此不管一个事务锁住页中一个记录还是多个记录，其开销通常都是一致的