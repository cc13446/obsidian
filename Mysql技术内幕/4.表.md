# 表
将从InnoDB存储引擎表的逻辑存储及实现开始进行介绍，然后将重点分析表的物理存储特征，即数据在表中是如何组织和存放的。简单来说，表就是关于特定实体的数据集合，这也是关系型数据库模型的核心

## 索引组织表
索引组织表指**表都是按照主键顺序存放的**。在InnoDB存储引擎的每张表都有主键，如果创建表的时候没有显示定义主键，那么存储引擎会按照如下方式选择或者创建主键：
1. 首先判断是否有非空的唯一索引，如果有则该列为主键
2. 自动创建一个6字节大小的指针

当表中有多个非空唯一索引时，InnoDB存储引擎将选择建表时第一个定义的非空唯一索引为主键。这里需要非常注意的是，主键的选择根据的是**定义索引的顺序**，而不是建表时列的顺序。

## InnoDB逻辑存储结构
有数据都被逻辑地存放在一个空间中，称之为表空间`tablespace`。表空间又由以下组成：
1. 段`segment`
2. 区`extent`
3. 页`page`，也称为块`block`
4. 行`row`

### 表空间
在默认情况下存储引擎有一个共享表空间`ibdata1`，即所有数据都存放在这个表空间内。如果用户启用了参数`innodb_file_per_table`，则每张表内的数据可以单独放到一个表空间内。需要注意的是每张表的表空间内存放的只是
1. 数据
2. 索引
3. 插入缓冲`Bitmap`页

原来的共享表空间存放
1. 回滚`undo`信息
2. 插入缓冲索引页
3. 系统事务信息
4. 二次写缓冲`Double write buffer`
5. ...

所以即使在启用了参数`innodb_file_per_table`之后，共享表空间还是会不断地增加其大小

### 段
表空间是由各个段组成的，常见的端有
1. 数据段
2. 索引段
3. 回滚段

InnoDB存储引擎表是索引组织的，因此数据即索引，索引即数据。那么数据段即为B+树的叶子节点，索引段即为B+树的非索引节点。

### 区
区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。为了保证区中页的连续性，存储引擎一次从磁盘申请4到5个区。在默认情况下，存储引擎页的大小为16KB，即一个区中一共有64个连续的页。

1.0.x版本开始引入压缩页，即每个页的大小可以通过参数`KEY_BLOCK_SIZE`设置为2K、4K、8K，因此每个区对应页的数量就应该为512、256、128。

1.2.x版本新增了参数`innodb_page_size`，通过该参数可以将默认页的大小设置为4K、8K，但是页中的数据库不是压缩。这时区中页的数量同样也为256、128。总之，不论页的大小怎么变化，区的大小总是为1M。

在用户启用了参数`innodb_file_per_talbe`后，创建的表默认大小是96KB。区中是64个连续的页，创建的表的大小至少是1MB才对啊？其实这是因为在每个段开始时，先用32个页大小的碎片页来存放数据，在使用完这些页之后才是64个连续页的申请。这样做的目的是，对于一些小表，或者是undo这类的段，可以在开始时申请较少的空间，节省磁盘容量的开销。

### 页
页是InnoDB磁盘管理的最小单位。在InnoDB存储引擎中，默认每个页的大小为16KB。从1.2.x版本开始，可以通过参数`innodb_page_size`将页的大小设置为4K、8K、16K。若设置完成，则所有表中页的大小都为`innodb_page_size`，不可以对其再次进行修改。除非通过`mysqldump`导入和导出操作来产生新的库。

在InnoDB存储引擎中，常见的页类型有：
1. 数据页`B-tree Node`
2. undo页`undo Log Page`
3. 系统页`System Page`
4. 事务数据页`Transaction system Page`
5. 插入缓冲位图页`Insert Buffer Bitmap`
6. 插入缓冲空闲列表页`Insert Buffer Free List`
7. 未压缩的二进制大对象页`Uncompressed BLOB Page`
8. 压缩的二进制大对象页`compressed BLOB Page`

### 行
InnoDB存储引擎的数据是按行进行存放的。

## InnoDB的行记录格式
`1.0.x`版本之前，InnoDB存储引擎提供了`Compact`和`Redundant`两种格式来存放行记录数据，这也是目前使用最多的一种格式。`Redundant`格式是为兼容之前版本而保留的。在MySQL 5.1版本中，默认设置为`Compact`行格式。用户可以通过命令`SHOW TABLE STATUS LIKE'table_name'`来查看当前表使用的行格式。

### Compact行记录格式
MySQL 5.0中引入，设计目标是高效地存储数据。简单来说，页中存放的行数据越多其性能就越高
![](4.表/Pasted%20image%2020220515162118.png)
#### 变长字段长度列表
行首部是一个非NULL变长字段长度列表，并且其是按照列的顺序逆序放置的，其长度为：
1. 若列的长度小于255字节，用1字节表示
2. 若大于255个字节，用2字节表示

变长字段的长度最大不可以超过2字节，在MySQL数据库中`VARCHAR`类型的最大长度限制为65535

#### NULL标志位列表
标识了该行数据中所有可为`NULL`的字段是否为`NULL`，是则用1表示，如果有多个可为 `NULL` 的字段，那么 `NULL` 值列表也是按照**逆序存储**的。而且 `NULL` 值列表的位数必须是 **8bit 的N倍**

#### 记录头信息
固定占用5字节：

| 名称           | 大小 (bit) | 描述                                      |
| -------------- | ---------- | ----------------------------------------- |
| 预留位1        | 1          | 没有使用                                  |
| 预留位2        | 1          | 没有使用                                  |
| `delete_mask`  | 1          | 标记该记录是否被删除                      |
| `min_rec_mask` | 1          | B+树里每一层的非叶子节点里的最小值标记为1 |
| `n_owned`      | 4          | 表示当前记录拥有的记录数                  |
| `heap_no`      | 13         | 表示当前记录在记录堆的位置信息            |
| `record_type`  | 3          | 标识当前记录的类型                        | 
| `next_record`  | 16         | 表示下一条记录的相对位置                  |

`record_type`：
- 0代表的是普通类型
- 1代表的是B+树非叶子节点
- 2代表的是最小值数据
- 3代表的是最大值数据
- 剩下保留 

#### 列数据
1. `NULL`不占该部分任何空间，即`NULL`除了占有`NULL`标志位，实际存储不占有任何空间。
2. 每行数据除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节
3. 若InnoDB表没有定义主键，每行还会增加一个6字节的`rowid`列

### Redundant行记录格式
![](4.表/Pasted%20image%2020220515174046.png)
#### 字段长度偏移列表
同样是按照列的顺序逆序放置的。若列的长度小于255字节，用1字节表示；若大于255字节，用2字节表示。存放着每个字段的开头对于整个行的偏移。

#### 记录头信息
不同于`Compact`行记录格式，`Redundant`行记录格式的记录头占用6字节

| 名称               | 大小 (bit) | 描述                                      |
| ------------------ | ---------- | ----------------------------------------- |
| 预留位1            | 1          | 没有使用                                  |
| 预留位2            | 1          | 没有使用                                  |
| `delete_flag`      | 1          | 标记该记录是否被删除                      |
| `min_rec_flag`     | 1          | B+树里每一层的非叶子节点里的最小值标记为1 |
| `n_owned`          | 4          | 表示当前记录拥有的记录数                  |
| `heap_no`          | 13         | 表示当前记录在记录堆的位置信息            |
| `n_fields`         | 10         | 记录中列的数量                            |
| `1byte_offs_flags` | 1          | 偏移列表是一字节还是两字节                | 
| `next_record`      | 16         | 表示下一条记录的相对位置                  |

`n_fields`值代表一行中列的数量，占用10位。同时这也很好地解释了为什么MySQL数据库一行支持最多的列为1023。


### 行溢出数据
InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。

#### VARCHAR总长度
`VARCHAR(N)`中的N指的是字符的长度。而文档中说明`VARCHAR`类型最大支持65535，单位是字节。而且指所有`VARCHAR`列的长度总和，如果列的长度总和超出这个长度，依然无法创建。

#### VARCHAR存储方式
`InnoDB`存储引擎的页为16KB，即16384字节，怎么能存放65532字节呢？因此，在一般情况下，`InnoDB`存储引擎的数据都是存放在页类型为`B-tree node`中。但是当发生行溢出时，数据存放在页类型为`Uncompress BLOB`页中。数据页面其实只保存了`VARCHAR(65532)`的前768字节的前缀数据，之后是偏移量，指向行溢出页，也就是`Uncompressed BLOB Page`。

多长的`VARCHAR是`保存在单个数据页中的，从多长开始又会保存在`BLOB`页呢？`InnoDB`存储引擎表是索引组织的，即`B+Tree`的结构，这样每个页中至少应该有两条行记录，否则失去`B+Tree`的意义变成链表了。因此，如果页中只能存放下一条记录，那么`InnoDB`存储引擎会自动将行数据存放到溢出页中。经过多次试验测试，发现这个阈值的长度为`8098`。

#### TEXT和BLOB的存储方式
对于`TEXT`或`BLOB`的数据类型，用户总是以为它们是存放在`Uncompressed BLOB Page`中的，其实这也是不准确的。是放在数据页中还是`BLOB`页中，和前面讨论的`VARCHAR`一样，要至少保证一个页能存放两条记录。当然既然用户使用了`BLOB`列类型，一般不可能存放长度这么小的数据。因此在大多数的情况下`BLOB`的行数据还是会发生行溢出，实际数据保存在`BLOB`页中，数据页只保存数据的前768字节。

### Compressed和Dynamic行记录格式
`1.0.x`版本开始引入了新的页格式，以前支持的`Compact`和`Redundant`格式称为`Antelope`文件格式，新的文件格式称为`Barracuda`文件格式。`Barracuda`文件格式下拥有两种新的行记录格式：
1. `Compressed`
2. `Dynamic`

![](4.表/Pasted%20image%2020220515193235.png)
新的两种记录格式对于存放在`BLOB`中的数据采用了完全的行溢出的方式，在数据页中只存放20个字节的指针，实际的数据都存放在`Off Page`中，而之前的`Compact`和`Redundant`两种格式会存放768个前缀字节。

`Compressed`行记录格式的另一个功能就是，存储在其中的行数据会以`zlib`的算法进行压缩，因此对于`BLOB`、`TEXT`、`VARCHAR`这类大长度类型的数据能够进行非常有效的存储。

### CHAR的行结构存储
通常理解`VARCHAR`是存储变长长度的字符类型，`CHAR`是存储固定长度的字符类型。而在前面的小节中，用户已经了解行结构的内部的存储，并可以发现每行的变长字段长度的列表都没有存储`CHAR`类型的长度。

然而，值得注意的是之前给出的两个例子中的字符集都是单字节的`latin1`格式。从`MySQL 4.1`版本开始，`CHAR(N)`中的N指的是字符的长度，而不是之前版本的字节长度。也就说在不同的字符集下，`CHAR`类型列内部存储的可能不是定长的数据

对于多字节的字符编码，`CHAR`类型不再代表固定长度的字符串了。例如：对于`UTF-8`下`CHAR(10)`类型的列，其最小可以存储10字节的字符，而最大可以存储30字节的字符。因此，对于多字节字符编码的`CHAR`数据类型的存储，`InnoDB`存储引擎在内部将其视为变长字符类型。这也就意味着在变长长度列表中会记录`CHAR`数据类型的长度。对于未能占满长度的字符填充`0x20`。可以认为在多字节字符集的情况下，`CHAR`和`VARCHAR`的实际行存储基本是没有区别的。

## InnoDB数据页结构
页是InnoDB存储引擎管理数据库的最小磁盘单位。页类型为`B-tree Node`的页存放的即是表中行的实际数据了




