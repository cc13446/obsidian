# 表
将从InnoDB存储引擎表的逻辑存储及实现开始进行介绍，然后将重点分析表的物理存储特征，即数据在表中是如何组织和存放的。简单来说，表就是关于特定实体的数据集合，这也是关系型数据库模型的核心

## 索引组织表
索引组织表指**表都是按照主键顺序存放的**。在InnoDB存储引擎的每张表都有主键，如果创建表的时候没有显示定义主键，那么存储引擎会按照如下方式选择或者创建主键：
1. 首先判断是否有非空的唯一索引，如果有则该列为主键
2. 自动创建一个6字节大小的指针

当表中有多个非空唯一索引时，InnoDB存储引擎将选择建表时第一个定义的非空唯一索引为主键。这里需要非常注意的是，主键的选择根据的是**定义索引的顺序**，而不是建表时列的顺序。

## InnoDB逻辑存储结构
有数据都被逻辑地存放在一个空间中，称之为表空间`tablespace`。表空间又由以下组成：
1. 段`segment`
2. 区`extent`
3. 页`page`，也称为块`block`
4. 行`row`

### 表空间
在默认情况下存储引擎有一个共享表空间`ibdata1`，即所有数据都存放在这个表空间内。如果用户启用了参数`innodb_file_per_table`，则每张表内的数据可以单独放到一个表空间内。需要注意的是每张表的表空间内存放的只是
1. 数据
2. 索引
3. 插入缓冲`Bitmap`页

原来的共享表空间存放
1. 回滚`undo`信息
2. 插入缓冲索引页
3. 系统事务信息
4. 二次写缓冲`Double write buffer`
5. ...

所以即使在启用了参数`innodb_file_per_table`之后，共享表空间还是会不断地增加其大小

### 段
表空间是由各个段组成的，常见的端有
1. 数据段
2. 索引段
3. 回滚段

InnoDB存储引擎表是索引组织的，因此数据即索引，索引即数据。那么数据段即为B+树的叶子节点，索引段即为B+树的非索引节点。

### 区
区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。为了保证区中页的连续性，存储引擎一次从磁盘申请4到5个区。在默认情况下，存储引擎页的大小为16KB，即一个区中一共有64个连续的页。

1.0.x版本开始引入压缩页，即每个页的大小可以通过参数`KEY_BLOCK_SIZE`设置为2K、4K、8K，因此每个区对应页的数量就应该为512、256、128。

1.2.x版本新增了参数`innodb_page_size`，通过该参数可以将默认页的大小设置为4K、8K，但是页中的数据库不是压缩。这时区中页的数量同样也为256、128。总之，不论页的大小怎么变化，区的大小总是为1M。

在用户启用了参数`innodb_file_per_talbe`后，创建的表默认大小是96KB。区中是64个连续的页，创建的表的大小至少是1MB才对啊？其实这是因为在每个段开始时，先用32个页大小的碎片页来存放数据，在使用完这些页之后才是64个连续页的申请。这样做的目的是，对于一些小表，或者是undo这类的段，可以在开始时申请较少的空间，节省磁盘容量的开销。

### 页
页是InnoDB磁盘管理的最小单位。在InnoDB存储引擎中，默认每个页的大小为16KB。从1.2.x版本开始，可以通过参数`innodb_page_size`将页的大小设置为4K、8K、16K。若设置完成，则所有表中页的大小都为`innodb_page_size`，不可以对其再次进行修改。除非通过`mysqldump`导入和导出操作来产生新的库。

在InnoDB存储引擎中，常见的页类型有：
1. 数据页`B-tree Node`
2. undo页`undo Log Page`
3. 系统页`System Page`
4. 事务数据页`Transaction system Page`
5. 插入缓冲位图页`Insert Buffer Bitmap`
6. 插入缓冲空闲列表页`Insert Buffer Free List`
7. 未压缩的二进制大对象页`Uncompressed BLOB Page`
8. 压缩的二进制大对象页`compressed BLOB Page`

### 行
InnoDB存储引擎的数据是按行进行存放的。

## InnoDB的行记录格式
`1.0.x`版本之前，InnoDB存储引擎提供了`Compact`和`Redundant`两种格式来存放行记录数据，这也是目前使用最多的一种格式。`Redundant`格式是为兼容之前版本而保留的。在MySQL 5.1版本中，默认设置为`Compact`行格式。用户可以通过命令`SHOW TABLE STATUS LIKE'table_name'`来查看当前表使用的行格式。

### Compact行记录格式
MySQL 5.0中引入，设计目标是高效地存储数据。简单来说，页中存放的行数据越多其性能就越高
![](4.表/Pasted%20image%2020220515162118.png)
#### 变长字段长度列表
行首部是一个非NULL变长字段长度列表，并且其是按照列的顺序逆序放置的，其长度为：
1. 若列的长度小于255字节，用1字节表示
2. 若大于255个字节，用2字节表示

变长字段的长度最大不可以超过2字节，在MySQL数据库中`VARCHAR`类型的最大长度限制为65535

#### NULL标志位列表
标识了该行数据中所有可为`NULL`的字段是否为`NULL`，是则用1表示，如果有多个可为 `NULL` 的字段，那么 `NULL` 值列表也是按照**逆序存储**的。而且 `NULL` 值列表的位数必须是 **8bit 的N倍**

#### 记录头信息
固定占用5字节：

| 名称           | 大小 (bit) | 描述                                      |
| -------------- | ---------- | ----------------------------------------- |
| 预留位1        | 1          | 没有使用                                  |
| 预留位2        | 1          | 没有使用                                  |
| `delete_mask`  | 1          | 标记该记录是否被删除                      |
| `min_rec_mask` | 1          | B+树里每一层的非叶子节点里的最小值标记为1 |
| `n_owned`      | 4          | 表示当前记录拥有的记录数                  |
| `heap_no`      | 13         | 表示当前记录在记录堆的位置信息            |
| `record_type`  | 3          | 标识当前记录的类型                        | 
| `next_record`  | 16         | 表示下一条记录的相对位置                  |

`record_type`：
- 0代表的是普通类型
- 1代表的是B+树非叶子节点
- 2代表的是最小值数据
- 3代表的是最大值数据
- 剩下保留 

#### 列数据
1. `NULL`不占该部分任何空间，即`NULL`除了占有`NULL`标志位，实际存储不占有任何空间。
2. 每行数据除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节
3. 若InnoDB表没有定义主键，每行还会增加一个6字节的`rowid`列

### Redundant行记录格式
![](4.表/Pasted%20image%2020220515174046.png)
#### 字段长度偏移列表
同样是按照列的顺序逆序放置的。若列的长度小于255字节，用1字节表示；若大于255字节，用2字节表示。存放着每个字段的开头对于整个行的偏移。

#### 记录头信息
不同于`Compact`行记录格式，`Redundant`行记录格式的记录头占用6字节

| 名称               | 大小 (bit) | 描述                                      |
| ------------------ | ---------- | ----------------------------------------- |
| 预留位1            | 1          | 没有使用                                  |
| 预留位2            | 1          | 没有使用                                  |
| `delete_flag`      | 1          | 标记该记录是否被删除                      |
| `min_rec_flag`     | 1          | B+树里每一层的非叶子节点里的最小值标记为1 |
| `n_owned`          | 4          | 表示当前记录拥有的记录数                  |
| `heap_no`          | 13         | 表示当前记录在记录堆的位置信息            |
| `n_fields`         | 10         | 记录中列的数量                            |
| `1byte_offs_flags` | 1          | 偏移列表是一字节还是两字节                | 
| `next_record`      | 16         | 表示下一条记录的相对位置                  |

`n_fields`值代表一行中列的数量，占用10位。同时这也很好地解释了为什么MySQL数据库一行支持最多的列为1023。


### 行溢出数据
InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。

#### VARCHAR总长度
`VARCHAR(N)`中的N指的是字符的长度。而文档中说明`VARCHAR`类型最大支持65535，单位是字节。而且指所有`VARCHAR`列的长度总和，如果列的长度总和超出这个长度，依然无法创建。

#### VARCHAR存储方式
`InnoDB`存储引擎的页为16KB，即16384字节，怎么能存放65532字节呢？因此，在一般情况下，`InnoDB`存储引擎的数据都是存放在页类型为`B-tree node`中。但是当发生行溢出时，数据存放在页类型为`Uncompress BLOB`页中。数据页面其实只保存了`VARCHAR(65532)`的前768字节的前缀数据，之后是偏移量，指向行溢出页，也就是`Uncompressed BLOB Page`。

多长的`VARCHAR是`保存在单个数据页中的，从多长开始又会保存在`BLOB`页呢？`InnoDB`存储引擎表是索引组织的，即`B+Tree`的结构，这样每个页中至少应该有两条行记录，否则失去`B+Tree`的意义变成链表了。因此，如果页中只能存放下一条记录，那么`InnoDB`存储引擎会自动将行数据存放到溢出页中。经过多次试验测试，发现这个阈值的长度为`8098`。

#### TEXT和BLOB的存储方式
对于`TEXT`或`BLOB`的数据类型，用户总是以为它们是存放在`Uncompressed BLOB Page`中的，其实这也是不准确的。是放在数据页中还是`BLOB`页中，和前面讨论的`VARCHAR`一样，要至少保证一个页能存放两条记录。当然既然用户使用了`BLOB`列类型，一般不可能存放长度这么小的数据。因此在大多数的情况下`BLOB`的行数据还是会发生行溢出，实际数据保存在`BLOB`页中，数据页只保存数据的前768字节。

### Compressed和Dynamic行记录格式
`1.0.x`版本开始引入了新的页格式，以前支持的`Compact`和`Redundant`格式称为`Antelope`文件格式，新的文件格式称为`Barracuda`文件格式。`Barracuda`文件格式下拥有两种新的行记录格式：
1. `Compressed`
2. `Dynamic`

![](4.表/Pasted%20image%2020220515193235.png)
新的两种记录格式对于存放在`BLOB`中的数据采用了完全的行溢出的方式，在数据页中只存放20个字节的指针，实际的数据都存放在`Off Page`中，而之前的`Compact`和`Redundant`两种格式会存放768个前缀字节。

`Compressed`行记录格式的另一个功能就是，存储在其中的行数据会以`zlib`的算法进行压缩，因此对于`BLOB`、`TEXT`、`VARCHAR`这类大长度类型的数据能够进行非常有效的存储。

### CHAR的行结构存储
通常理解`VARCHAR`是存储变长长度的字符类型，`CHAR`是存储固定长度的字符类型。而在前面的小节中，用户已经了解行结构的内部的存储，并可以发现每行的变长字段长度的列表都没有存储`CHAR`类型的长度。

然而，值得注意的是之前给出的两个例子中的字符集都是单字节的`latin1`格式。从`MySQL 4.1`版本开始，`CHAR(N)`中的N指的是字符的长度，而不是之前版本的字节长度。也就说在不同的字符集下，`CHAR`类型列内部存储的可能不是定长的数据

对于多字节的字符编码，`CHAR`类型不再代表固定长度的字符串了。例如：对于`UTF-8`下`CHAR(10)`类型的列，其最小可以存储10字节的字符，而最大可以存储30字节的字符。因此，对于多字节字符编码的`CHAR`数据类型的存储，`InnoDB`存储引擎在内部将其视为变长字符类型。这也就意味着在变长长度列表中会记录`CHAR`数据类型的长度。对于未能占满长度的字符填充`0x20`。可以认为在多字节字符集的情况下，`CHAR`和`VARCHAR`的实际行存储基本是没有区别的。

## InnoDB数据页结构
页是InnoDB存储引擎管理数据库的最小磁盘单位。页类型为`B-tree Node`的页存放的即是表中行的实际数据了。

InnoDB数据页由以下7个部分组成：
1. `File Header`：文件头
2. `Page Header`：页头
3. `Infimun`和`Supremum Records`：最小、最大记录
4. `User Records`：用户记录，即行记录
5. `Free Space`：空闲空间
6. `Page Directory`：页目录
7. `File Trailer`：文件结尾信息

![](4.表/Pasted%20image%2020220516103147.png)
### File Header
用来记录页的一些头信息，共占用38字节。

| 名称                               | `B` | 说明                                          |     |
| ---------------------------------- | --- | --------------------------------------------- | --- |
| `FIL_PAGE_SPACE_OR_CHKSUM`         | 4   | `4.0.14`之前为0，之后为页的`checksum`         |     |
| `FIL_PAGE_OFFSET`                  | 4   | 表空间中页的偏移值，从0开始                           |     |
| `FIL_PAGE_PREV`                    | 4   | 当前页的上一个页，B+树的叶子节点              |     |
| `FIL_PAGE_NEXT`                    | 4   | 当前页的下一个页，B+树的叶子节点              |     |
| `FIL_PAGE_LSN`                     | 8   | 该页最后被修改的日志序列位置LSN               |     |
| `FIL_PAGE_TYPE`                    | 2   | 存储引擎页的类型                              |     |
| `FIL_PAGE_FLUSH_LSN`               | 8   | 系统表空间中该文件至少更新到的LSN |     |
| `FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID` | 4   | `4.1`开始代表该页属于那个表空间                 |     |

| 名称                    | 16进制 | 解释                   |
| ----------------------- | ------ | ---------------------- |
| `FIL_PAGE_INDEX`          | 0x45BF | B+树叶子节点           |
| `FIL_PAGE_UNDO_LOG`       | 0x0002 | Undo Log 页            |
| `FIL_PAGE_INODE`          | 0x0003 | 索引节点               |
| `FIL_PAGE_IBUF_FREE_LIST` | 0x0004 | Insert Buffer 空闲列表 |
| `FIL_PAGE_TYPE_ALLOCATED` | 0x0000 | 最新分配               |
| `FIL_PAGE_IBUF_BITMAP`    | 0x0005 | Insert Buffer位图      |
| `FIL_PAGE_TYPE_SYS`       | 0x0006 | 系统页                 |
| `FIL_PAGE_TYPE_TRX_SYS`   | 0x0007 | 事务系统数据           |
| `FIL_PAGE_TYPE_FSP_HDR`   | 0x0008 | File Space Header      |
| `FIL_PAGE_TYPE_XDED`      | 0x0009 | 拓展描述页             |
| `FIL_PAGE_TYPE_BLOB`      | 0x000A | BLOB页                 | 

### Page Header
用来记录数据页的状态信息，由14个部分组成，共占用56字节。记录在页中根据堆的形式存放

| 名称                | B   | 说明                                                 |
| ------------------- | --- | ---------------------------------------------------- |
| `PAGE_N_DIR_SLOTS`  | 2   | 页目录的Slot数                                       |
| `PAGE_HEAP_TOP`     | 2   | 堆第一个记录的指针，空闲空间开始位置的偏移量         |
| `PAGE_N_HEAP`       | 2   | 堆的记录数，第15为是行记录格式                       |
| `PAGE_FREE`         | 2   | 可重用空间的首指针                                   |
| `PAGE_GARBAGE`      | 2   | 已删除记录的字节数，`delete flag=1`的行              |
| `PAGE_LAST_INSERT`  | 2   | 最后插入记录的位置                                   |
| `PAGE_DIRECTION`    | 2   | 最后插入的方向                                       |
| `PAGE_N_DIRECTION`  | 2   | 一个方向连续插入记录的数量                           |
| `PAGE_N_RECS`       | 2   | 该页中记录的数量                                     |
| `PAGE_MAX_TRX_ID`   | 8   | 修改当前页的最大事务ID，仅在Secondary Index          |
| `PAGE_LEVEL`        | 2   | 在索引树中的位置                                     |
| `PAGE_INDEX_ID`     | 8   | 索引ID                                               |
| `PAGE_BTR_SEG_LEAF` | 10  | B+树数据页非叶节点所在段的segment head，仅B+树root页 |
| `PAGE_BTR_SEG_TOP`  | 10  | B+树数据页所在段的segment head，仅在B+树root页       |

`PAGE_DIRECTION`：
1. `PAGE_LEFT`：0x01
2. `PAGE_RIGHT`：0x02
3. `PAGE_SAME_REC`：0x03
4. `PAGE_SAME_PAGE`：0x04
5. `PAGE_NO_DIRECTION`：0x05

### Infimum和Supremum Record
在InnoDB存储引擎中，每个数据页中有两个虚拟的行记录，用来限定记录的边界。`Infimum`记录是比该页中任何主键值都要小的值，`Supremum`指比任何可能大的值还要大的值。这两个值在页创建时被建立，并且在任何情况下不会被删除。在`Compact`行格式和`Redundant`行格式下，两者占用的字节数各不相同。

### User Record和Free Space
`User Record`就是实际存储行记录的地方。InnoDB存储引擎表总是B+树索引组织的。

`Free Space`很明显指的就是空闲空间，同样也是个链表数据结构。在一条记录被删除后，该空间会被加入到空闲链表中。

### Page Directory
页目录中存放了记录对于页的相对位置，有些时候这些记录指针称为Slots。与其他数据库系统不同的是，在`InnoDB`中并不是每个记录有一个槽，`InnoDB`存储引擎的槽是一个稀疏目录，即一个槽中可能包含多个记录。伪记录`Infimum`拥有的记录数总是为1，记录`Supremum`拥有的记录数取值范围为`[1，8]`，其他用户记录`n_owned`的取值范围为`[4，8]`。当记录被插入或删除时需要对槽进行分裂或平衡的维护操作。在`Slots`中记录按照索引键值顺序存放，这样可以利用二叉查找迅速找到记录的指针。

假设有`('i','d','c','b','e','g','l','h','f','j','k','a')`，同时假设一个槽中包含4条记录，则Slots中的记录可能是`('a','e','i')`。需要注意的是，Page Directory是逆序存放的，每个槽占2字节。

由于在`InnoDB`存储引擎中`Page Direcotry`是稀疏目录，二叉查找的结果只是一个粗略的结果，因此`InnoDB`存储引擎必须通过`recorder header`中的`next_record`来继续查找相关记录。同时，`Page Directory`很好地解释了`recorder header`中的`n_owned`值的含义，因为这些记录并不包括在`Page Directory`中。

需要牢记的是，B+树索引本身并不能找到具体的一条记录，能找到只是该记录所在的页。数据库把页载入到内存，然后通过`Page Directory`再进行二叉查找。只不过二叉查找的时间复杂度很低，同时在内存中的查找很快，因此通常忽略这部分查找所用的时间。

### File Trailer
为了检测页是否已经完整地写入磁盘，`InnoDB`存储引擎的页中设置了`File Trailer`部分。

`File Trailer`只有一个`FIL_PAGE_END_LSN`部分，占用8字节。前4字节代表该页的`checksum`值，最后4字节和`File Header`中的`FIL_PAGE_LSN`相同。

将这两个值与`File Header`中的`FIL_PAGE_SPACE_OR_CHKSUM`和`FIL_PAGE_LSN`值进行比较，看是否一致来保证页的完整性。其中`checksum`的比较需要通过`InnoDB`的`checksum`函数来进行比较，不是简单的等值比较。

在默认配置下，InnoDB存储引擎每次从磁盘读取一个页就会检测该页的完整性。用户可以通过参数`innodb_checksums`来开启或关闭对这个页完整性的检查。从`MySQL 5.6.6`版本开始新增了参数`innodb_checksum_algorithm`，用来控制检测`checksum`函数的算法。

## Named File Formats机制
InnoDB存储引通过`Named File Formats`机制来解决不同版本下页结构兼容性的问题。

## 约束
### 数据完整性
关系型数据库系统和文件系统的一个不同点是，关系数据库本身能保证存储数据的完整性，不需要应用程序的控制，而文件系统一般需要在程序端进行控制。当前几乎所有的关系型数据库都提供了约束机制，该机制提供了一条强大而简易的途径来保证数据库中数据的完整性。一般来说，数据完整性有以下三种形式：
1. 实体完整性：主键
2. 域完整性：保证数据每列的值满足特定的条件
3. 参照完整性保证两张表之间的关系

对于InnoDB存储引擎本身而言，提供了以下几种约束：
1. `Primary Key`
2. `Unique Key`
3. `Foreign Key`
4. `Default`
5. `NOT NULL`
6. 编写触发器

### 约束的创建和查找
约束的创建可以采用以下两种方式：
1. 表建立时就进行约束定义
2. 利用`ALTER TABLE`命令来进行创建约束

对`Unique Key`的约束，用户还可以通过命令`CREATE UNIQUE INDEX`来建立。对于主键约束而言，其默认约束名为`PRIMARY`。而对于`Unique Key`约束而言，默认约束名和列名一样，当然也可以人为指定`Unique Key`约束的名字。`Foreign Key`约束似乎会有一个比较神秘的默认名称。

### 约束和索引的区别
当用户创建了一个唯一索引就创建了一个唯一的约束。但是约束和索引的概念还是有所不同的，约束更是一个逻辑的概念，用来保证数据的完整性，而索引是一个数据结构，既有逻辑上的概念，在数据库中还代表着物理存储的方式。

### 对错误数据的约束
在某些默认设置下，MySQL数据库允许非法的或不正确的数据的插入或更新，又或者可以在数据库内部将其转化为一个合法的值，如向`NOT NULL`的字段插入一个`NULL`值，MySQL数据库会将其更改为0再进行插入。如果用户想通过约束对于数据库非法数据的插入或更新，即MySQL数据库提示报错而不是警告，那么用户必须设置参数`sql_mode`，用来严格审核输入的参数。

### ENUM和SET约束
MySQL数据库不支持传统的`CHECK`约束，但是通过`ENUM`和`SET`类型可以解决部分这样的约束需求，但是只限于对离散数值的约束。

### 触发器与约束
完整性约束通常也可以使用触发器来实现，因此在了解数据完整性前先对触发器来做一个了解。


#### 了解触发器
触发器的作用是在执行`INSERT`、`DELETE`和`UPDATE`命令之前或之后自动调用SQL命令或存储过程。创建触发器的命令是`CREATE TRIGGER`，只有具备Super权限的MySQL数据库用户才可以执行这条命令。

最多可以为一个表建立6个触发器，即分别为`INSERT`、`UPDATE`、`DELETE`的`BEFORE`和`AFTER`各定义一个。`BEFORE`和`AFTER`代表触发器发生的时间，表示是在每行操作的之前发生还是之后发生。当前MySQL数据库只支持`FOR EACH ROW`的触发方式，即按每行记录进行触发，不支持像DB2的`FOR EACH STATEMENT`的触发方式。

### 外键约束
外键用来保证参照完整性，MySQL数据库的`MyISAM`存储引擎本身并不支持外键，对于外键的定义只是起到一个注释的作用。而`InnoDB`存储引擎则完整支持外键约束。

一般来说，称被引用的表为父表，引用的表称为子表。外键定义时的`ON DELETE`和`ON UPDATE`表示在对父表进行`DELETE`和`UPDATE`操作时，对子表所做的操作，可定义的子表操作有：
1. `CASCADE`：当父表发生操作时，对相应的子表中的数据也进行相应操作
2. `SET NULL`：当父表发生操作时，相应的子表中的数据被更新为NULL值
	- 子表中相对应的列必须允许为NULL值
3. `NO ACTION`：抛出错误，不允许这类操作发生
4. `RESTRICT`：抛出错误，不允许这类操作发生

在其他数据库中，如Oracle数据库，有一种称为延时检查的外键约束，即检查在SQL语句运行完成后再进行。而目前MySQL数据库的外键约束都是即时检查，因此从上面的定义可以看出，MySQL数据库中`NO ACTION`和`RESTRICT`的功能是相同的。

InnoDB存储引擎在外键建立时会自动地对该列加一个索引，可以很好地避免外键列上无索引而导致的死锁问题的产生。

## 视图
在MySQL数据库中，视图是一个命名的虚表，它由一个SQL查询来定义，可以当做表使用。与持久表不同的是，视图中的数据没有实际的物理存储。

### 视图的作用
视图在数据库中发挥着重要的作用。主要用途之一是被用做一个抽象装置，特别是对于一些应用程序，程序本身不需要关心基表的结构，只需要按照视图定义来取数据或更新数据，因此，视图同时在一定程度上起到一个安全层的作用。

虽然视图是基于基表的一个虚拟表，但是用户可以对某些视图进行更新操作，其本质就是通过视图的定义来更新基本表。一般称可以进行更新操作的视图为可更新视图。

视图定义中的`WITH CHECK OPTION`就是针对于可更新的视图的，即更新的值是否需要检查。

### 物化视图
Oracle数据库支持物化视图：该视图不是基于基表的虚表，而是根据基表实际存在的实表，即物化视图的数据存储在非易失的存储设备上。物化视图可以用于预先计算并保存多表的链接或聚集等耗时较多的SQL操作结果。这样，在执行复杂查询时，就可以避免进行这些耗时的操作，从而快速得到结果。物化视图的好处是对于一些复杂统计类查询能直接查出结果。在`Microsoft SQL Server`数据库中，称这种视图为索引视图。

MySQL数据库本身并不支持物化视图，换句话说，MySQL数据库中的视图总是虚拟的。但是用户可以通过一些机制来实现物化视图的功能。

## 分区表
分区功能并不是在存储引擎层完成的，因此不是只有`InnoDB`存储引擎支持分区，常见的存储引擎`MyISAM`、`NDB`等都支持。但也并不是所有的存储引擎都支持，如`CSV`、`FEDORATED`、`MERGE`等就不支持。在使用分区功能前，应该对选择的存储引擎对分区的支持有所了解。

MySQL数据库在5.1版本时添加了对分区的支持。分区的过程是将一个表或索引分解为多个更小、更可管理的部分。就访问数据库的应用而言，从逻辑上讲，只有一个表或一个索引，但是在物理上这个表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。

MySQL数据库支持的分区类型为水平分区但并不支持垂直分区。此外，MySQL数据库的分区是局部分区索引，一个分区中既存放了数据又存放了索引。而全局分区是指，数据存放在各个分区中，但是所有数据的索引放在一个对象中。目前，MySQL数据库还不支持全局分区。
1. 水平分区：将同一表中不同行的记录分配到不同的物理文件中。 
2. 垂直分区，指将同一表中不同列的记录分配到不同的物理文件中

当前MySQL数据库支持以下几种类型的分区：
1. `RANGE`分区：行数据基于属于一个给定连续区间的列值被放入分区
2. `LIST`分区：和`RANGE`分区类似，只是`LIST`分区面向的是离散的值
3. `HASH`分区：根据用户自定义的表达式的返回值来进行分区，返回值不能为负数
4. `KEY`分区：根据MySQL数据库提供的哈希函数来进行分区
5. `COLUMNS`分区：可视为`RANGE`分区和`LIST`分区的一种进化，直接使用非整型的数据进行分区
	1. `RANGE COLUMNS`分区：可以对多个列的值进行分区
	2. `LIST COLUMNS`分区

不论创建何种类型的分区，如果表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。

### 子分区
子分区是在分区的基础上再进行分区，有时也称这种分区为复合分区。MySQL数据库允许在`RANGE`和`LIST`的分区上再进行`HASH`或`KEY`的子分区

子分区的建立需要注意以下几个问题：
1. 每个子分区的数量必须相同。
2. 一个分区表的任何分区上使用`SUBPARTITION`来定义任何子分区，就必须定义所有的子分区
3. 每个`SUBPARTITION`子句必须包括子分区的一个名字
4. 子分区的名字必须是唯一的

### 分区中的NULL值

MySQL数据库允许对`NULL`值做分区，但是处理的方法与其他数据库可能完全不同。MySQL数据库的分区总是视`NULL`值视小于任何的一个非`NULL`值，这和MySQL数据库中处理`NULL`值的`ORDER BY`操作是一样的。因此对于不同的分区类型，MySQL数据库对于`NULL`值的处理也是各不相同。
1. 对于`RANGE`分区，如果向分区列插入了`NULL`值，则MySQL数据库会将该值放入最左边的分区
2. 在`LIST`分区下要使用`NULL`值，则必须显式地指出哪个分区中放入`NULL`值，否则会报错
3. `HASH`和`KEY`分区的任何分区函数都会将含有`NULL`值的记录返回为

### 分区和性能
对于OLAP的应用，分区的确是可以很好地提高查询的性能，因为OLAP应用大多数查询需要频繁地扫描一张很大的表。假设有一张1亿行的表，其中有一个时间戳属性列。用户的查询需要从这张表中获取一年的数据。如果按时间戳进行分区，则只需要扫描相应的分区即可。

然而对于OLTP的应用，分区应该非常小心。在这种应用下，通常不可能会获取一张大表中10%的数据，大部分都是通过索引返回几条记录即可。而根据B+树索引的原理可知，对于一张大表，一般的B+树需要2到3次的磁盘IO。因此B+树可以很好地完成操作，不需要分区的帮助，并且设计不好的分区会带来严重的性能问题。对于非分区列的查询操作可能需要在每一个分区都进行查询，加倍了IO操作。

### 在表和分区间交换数据
`MySQL 5.6`开始支持`ALTER TABLE … EXCHANGE PARTITION`语法。该语句允许分区或子分区中的数据与另一个非分区的表中的数据进行交换。如果非分区表中的数据为空，那么相当于将分区中的数据移动到非分区表中。若分区表中的数据为空，则相当于将外部表中的数据导入到分区中。

要使用`ALTER TABLE … EXCHANGE PARTITION`语句，必须满足下面的条件：
1. 要交换的表需和分区表有着相同的表结构，但是表不能含有分区
2. 在非分区表中的数据必须在交换的分区定义内
3. 被交换的表中不能含有外键，或者其他的表含有对该表的外键引用
4. 除了需要`ALTER`、`INSERT`和`CREATE`权限外，还需要`DROP`的权限

此外，有两个小的细节需要注意：
1. 使用该语句时，不会触发交换表和被交换表上的触发器
2. `AUTO_INCREMENT`列将被重置



