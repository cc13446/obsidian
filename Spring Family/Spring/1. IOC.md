### @Autowired的注入逻辑
1. 优先`ByType`进行注入，如果找到了对应的唯一`Bean`则直接返回
2. 其次`ByName`进行注入，如果还是找不到唯一的`Bean`则报错
3. `@Qualifier` 可以指定`Bean`的名字，同时拥有此注解时直接`ByName`
4. `@Primary`注解标注的`Bean`具有更高的优先级被注入
5. `required=false`可以允许注入失败，不抛出异常

#### @Resource
`JSR250`规范中的注解，`ByName`进行注入

#### @Inject
`JSR330`规范中的注解，优先`ByType`注入，可以配合`@Named`进行`ByName`注入


### FactoryBean
```java
public class ToyFactoryBean implements FactoryBean<Toy> {
    
    private Child child;
	
	// 根据child的不同生产不同的Bean
    @Override
    public Toy getObject() throws Exception {
        switch (child.getWantToy()) {
            case "ball":
                return new Ball("ball");
            case "car":
                return new Car("car");
            default:
                // SpringFramework2.0开始允许返回null
                // 之前的1.x版本是不允许的
                return null;
        }
    }
    
    @Override
    public Class<Toy> getObjectType() {
        return Toy.class;
    }
    
    public void setChild(Child child) {
        this.child = child;
    }    
}
```

#### FactoryBean的加载时机
`FactoryBean` 本身的加载是伴随 IOC 容器的初始化时机一起的

#### 创建Bean的时机
`FactoryBean` 生产 Bean 的机制是延迟生产

### Bean的生命周期

普通对象的生命周期：
1. **创建 / 实例化阶段**：此时会调用类的构造方法，产生一个新的对象
2. **初始化阶段**：此时对象已经创建好，但还没有被正式使用
3. **运行使用期**：此时对象已经完全初始化好，程序正常运行，对象被使用
4. **销毁阶段**：此时对象准备被销毁，已不再使用，需要预先的把自身占用的资源等处理好
5. **回收阶段**：此时对象已经完全没有被引用了，被垃圾回收器回收

`Spring`可以控制的生命周期：初始化阶段和销毁阶段
```java
// 方式1
public class Dog {
    
    private String name;
    
    public void setName(String name) {
        this.name = name;
    }

    public void init() {
        System.out.println(name + "被初始化了。。。");
    }
    public void destroy() {
        System.out.println(name + "被销毁了。。。");
    }
}

// 原型 Bean 在销毁时不处理 destroy-method 标注的方法。
@Bean(initMethod = "init", destroyMethod = "destroy")
public Dog dog() {
	Dog dog = new Dog();
	dog.setName("wangwang");
	return dog;
}

// 方式2
@PostConstruct
public void addInk() {
	System.out.println("钢笔中已加满墨水。。。");
	this.ink = 100;
}

@PreDestroy
public void outwellInk() {
	System.out.println("钢笔中的墨水都放干净了。。。");
	this.ink = 0;
}

// 方式3
@Component
public class Pen implements InitializingBean, DisposableBean {
    
    private Integer ink;
    
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("钢笔中已加满墨水。。。");
        this.ink = 100;
    }
    
    @Override
    public void destroy() throws Exception {
        System.out.println("钢笔中的墨水都放干净了。。。");
        this.ink = 0;
    }
    
    @Override
    public String toString() {
        return "Pen{" + "ink=" + ink + '}';
    }
}

// 三种方式可以共存，2 > 3 > 1
```

调用顺序如下：
1. 构造方法
2. `set`注入
3. `init`方法
4. `destroy`方法


### 监听器
这里用了观察者模式。

可以把 `SpringFramework` 的事件驱动核心概念划分为 4 个：
1. 事件源：发布事件的对象
2. 事件：事件源发布的信息 / 作出的动作
3. 广播器：事件真正广播给监听器的对象【即 **`ApplicationContext`** 】
	- `ApplicationEventPublisher` 接口，具备事件广播器的发布事件的能力
	- `ApplicationEventMulticaster` 组合了所有的监听器，具备事件广播器的广播事件的能力
4. 监听器：监听事件的对象


#### 继承式监听器和注解式监听器
