# 压缩列表
压缩列表是列表键和哈希键的底层实现之一。

当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。

当一个哈希键只包含少量键值对，比且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。

## 压缩列表的构成
压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。
![](7.压缩列表/Pasted%20image%2020220524145308.png)
字段说明：
1. `zlbytes`：记录整个压缩列表占用的内存字节数：进行内存重分配和计算`zlend`位置时使用
2. `zltail`：记录压缩列表表尾节点距离压缩列表的起始位置有多少字节
3. `zllen`：记录了压缩列表的节点数量，等于`UINT16_MAX`时节点真实数量需要遍历计算
4. `zlend`：特殊值`0xFF`， 标记压缩列表的尾端

## 压缩列表节点的构成
压缩列表节点可以保存一个字节数组或者一个整数值：
1. 字节数组可以是以下三种长度的其中一种：
	1. 长度小于等于63字节的字节数组
	2. 长度小于等于16383字节的字节数组
	3. 长度小于等于4294967295字节的字节数组
2. 整数值则可以是以下六种长度的其中一种：
	1. 4位长，介于0至12之间的无符号整数
	2. 1字节长的有符号整数
	3. `int16_t`类型整数
	4. 3字节长的有符号整数
	5. `int32_t`类型整数
	6. `int64_t`类型整数

具体的结构如下：
![](7.压缩列表/Pasted%20image%2020220524155128.png)
### previous_entry_length
以字节为单位，记录了压缩列表中前一个节点的长度，长度可以是1字节或者5字节：
1. 前一节点的长度小于254字节，那么属性的长度为1字节
2. 前一节点的长度大于等于254字节，那么属性的长度为5字节
	1. 属性的第一字节会被设置为`0xFE`
	2. 之后的四个字节则用于保存前一节点的长度

#### 遍历过程
从表尾节点向表头节点进行遍历的完整过程：
1. 通过压缩列表起始地址的指针加上`zltail`属性的值得出压缩列表表尾节点起始地址的指针
2. 通过压缩列表节点A起始地址的指针和`previous_entry_length`属性得到前一个节点地址
3. 从表尾节点向表头节点遍历了整个列表

### encoding
记录了节点的`content`属性所保存数据的类型以及长度：
1. 最高两位为`11`：`content`保存整数值，类型和长度由编码除去最高两位之后的其他位记录
	- 一字节长
2. 最高两位不为`11`：`content`保存字节数组，数组长度由编码除去最高两位之后的其他位记录
	- 一字节、两字节或者五字节长

#### 整数编码
![](7.压缩列表/Pasted%20image%2020220524210208.png)

#### 字节数组编码
![](7.压缩列表/Pasted%20image%2020220524210128.png)

### content
负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的`encoding`属性决定。

## 连锁更新
因为每个节点的`previous_entry_length`属性都记录了前一个节点的长度，所以前一个节点的长度变化必须要更新当前节点的`previous_entry_length`属性，甚至会进行扩展，这样就必须要更新后一个节点的`previous_entry_length`属性。这样就形成了连锁更新。

因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为`O(N)`，所以连锁更新的最坏复杂度为`N`的平方。

## 压缩列表API
![](7.压缩列表/Pasted%20image%2020220524211711.png)
