# 对象
Redis用到很多数据结构
1. 简单动态字符串
2. 双端链表
3. 字典
4. 压缩列表
5. 整数集合

Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种前面的数据结构。

通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。

使用对象的另一个好处是，我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。

除此之外，Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。

最后，Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了`maxmemory`功能的情况下，空转时长较大的那些键可能会优先被服务器删除。

## 对象的类型与编码
Redis使用对象来表示数据库中的键和值，每当在Redis的数据库中新创建一个键值对，至少会创建两个对象，一个对象用作键值对的键，另一个对象用作键值对的值。
```c
typedef struct redisObject {  
  
    // 类型  
    unsigned type:4;  
  
    // 编码  
    unsigned encoding:4;  
  
    // 指向底层实现数据结构的指针  
    void *ptr;  
  
    // ...  
  
} robj;
```
### 类型
对象的`type`属性记录了对象的类型，Redis的键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种，因此：
1. 当称呼一个数据库键为`字符串键`时，指的是这个数据库键所对应的值为字符串对象
2. 当称呼一个键为`列表键`时，指的是这个数据库键所对应的值为列表对象

| 对象         | 对象`type`属性的值 | `TYPE`命令的输出 |
| ------------ | ------------------ | ---------------- |
| 字符串对象   | REDIS_STRING       | "string"         |
| 列表对象     | REDIS_LIST         | "list"           |
| 哈希对象     | REDIS_HASH         | "hash"           |
| 集合对象     | REDIS_SET          | "set"            |
| 有序集合对象 | REDIS_ZSET         | "zset"           | 

### 编码和底层实现
`encoding`属性记录了对象所使用的编码，即这个对象使用了什么数据结构作为对象的底层实现
![](8.对象/Pasted%20image%2020220525101913.png)

每种类型的对象都至少使用了两种不同的编码：
![](8.对象/Pasted%20image%2020220525102436.png)

通过`encoding`属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。

`OBJECT ENCODING`命令可以查看一个数据库键的值对象的编码

## 字符串对象
字符串对象的编码可以是
1. `int`
2. `raw`
3. `embstr`

编码选择的规则是：
1. 字符串对象保存整数值，并且可以用`long`类型来表示，则`ptr`直接保存这个值，编码为`int`
2. 字符串对象保存字符串值，并且长度大于`32`字节，则`ptr`指向一个`SDS`，编码为`raw`
3. 字符串对象保存字符串值，并且长度小于等于`32`字节，则使用`embstr`编码的方式保存

`embstr`编码是专门用于保存短字符串的一种优化编码方式，这种编码和`raw`编码一样，都使用`redisObject`结构和`sdshdr`结构来表示字符串对象，但`raw`编码会调用两次内存分配函数来分别创建`redisObject`结构和`sdshdr`结构，而`embstr`编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含`redisObject`和`sdshdr`两个结构
![](8.对象/Pasted%20image%2020220525105211.png)
有以下好处：
1. 将创建字符串对象所需的内存分配次数从`raw`编码的两次降低为一次
2. 释放`embstr`编码的字符串对象调用一次内存释放函数，而释放`raw`编码的需要调用两次
3. 能够更好地利用缓存带来的优势

可以用`double`类型表示的浮点数在Redis中也是作为字符串值来保存的。如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值。也就是说底层用`raw`或者`embstr`保存，但是可以转换成`double`类型来参与运算。

### 编码的转换
`int`编码的字符串对象和`embstr`编码的字符串对象在条件满足的情况下，会被转换为`raw`编码的字符串对象：
1. `int`编码的字符串对象不能用`long`来保存的时候会转变为`raw`编码
2. `embstr`编码实际上是只读的，没有相应的修改程序，当修改时会转换成`raw`

## 列表对象
列表对象的编码可以是
1. `ziplist`
2. `linkedlist`

`linkedlist`编码的列表对象在底层的双端链表结构中包含了多个字符串对象，这种嵌套字符串对象的行为在哈希对象、集合对象和有序集合对象中都会出现，字符串对象是Redis五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象。

### 编码转换
当列表对象可以同时满足以下两个条件时，列表对象使用`ziplist`编码：
1. 列表对象保存的所有字符串元素的长度都小于`64`字节
2. 列表对象保存的元素数量小于`512`个

不能满足这两个条件的列表对象需要使用`linkedlist`编码，这两个条件的上限值是可以修改的。

对于使用`ziplist`编码的列表对象来说，当使用`ziplist`编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行，原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面，对象的编码也会从`ziplist`变为`linkedlist`。

## 哈希对象
哈希对象的编码可以是
1. `ziplist`
2. `hashtable`

### 压缩列表实现
当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：
1. 保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后
2. 先添加到哈希对象中的键值对会被放在压缩列表的表头方向
3. 后添加到哈希对象中的键值对会被放在压缩列表的表尾方向

### 哈希表实现
哈希对象中的每个键值对都使用一个字典键值对来保存：
1. 字典的每个键都是一个字符串对象，对象中保存了键值对的键
2. 字典的每个值都是一个字符串对象，对象中保存了键值对的值

### 编码转换
当哈希对象可以同时满足以下两个条件时，哈希对象使用`ziplist`编码：
1. 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节
2. 哈希对象保存的键值对数量小于512个

不能满足这两个条件的哈希对象需要使用`hashtable`编码，这两个条件的上限值是可以修改的。

对于使用`ziplist`编码的列表对象来说，当使用`ziplist`编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行，原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面，对象的编码也会从`ziplist`变为`hashtable`。

## 集合对象
集合对象的编码可以是
1. `intset`
2. `hashtable

### 整数集合实现
`intset`编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。

### 哈希表实现
`hashtable`编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为`NULL`。

### 编码转换
当集合对象可以同时满足以下两个条件时，对象使用`intset`编码：
1. 集合对象保存的所有元素都是整数值
2. 集合对象保存的元素数量不超过512个

不能满足这两个条件的集合对象需要使用`hashtable`编码，第二个条件的上限值是可以修改的

## 有序集合对象
有序集合的编码可以是
1. `ziplist`
2. `skiplist`

### 压缩列表实现
`ziplist`编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，而第二个元素则保存元素的分值。

压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。

### 跳跃表和字典实现
有序集合对象使用`zset`结构作为底层实现，一个`zset`结构同时包含一个字典和一个跳跃表：
```c
typedef struct zset {  

    zskiplist *zsl;  
    
    dict *dict;  
    
} zset;
```

跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：
1. 跳跃表节点的`object`属性保存了元素的成员
2. 跳跃表节点的`score`属性则保存了元素的分值

通过这个跳跃表，程序可以对有序集合进行范围型操作

字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：
1. 字典的键保存了元素的成员
2. 字典的值保存了元素的分值

通过这个字典，程序可以用`O(1)`复杂度查找给定成员的分值

有序集合每个元素的成员都是一个字符串对象，每个元素的分值都是一个`double`类型的浮点数。值得一提的是，虽然`zset`结构同时使用跳跃表和字典来保存有序集合元素，但这两种数据结构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，也不会因此而浪费额外的内存。

#### 为什么有序集合需要同时使用跳跃表和字典来实现？
在理论上，有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现，但无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低。为了同时以较低的时间复杂度同时支持范围查询和和单一查询，Redis选择了同时使用字典和跳跃表两种数据结构来实现有序集合。

### 编码的转换
当有序集合对象可以同时满足以下两个条件时，对象使用`ziplist`编码：
1. 有序集合保存的元素数量小于128个
2. 有序集合保存的所有元素成员的长度都小于64字节

不能满足以上两个条件的有序集合对象将使用`skiplist`编码，两个条件的上限值是可以修改的。

## 类型检查与命令多态
Redis中用于操作键的命令基本上可以分为两种类型：
1. 可以对任何类型的键执行，比如：`DEL`、`EXPIRE`、`RENAME`、`TYPE`、`OBJECT`等
2. 只能对特定类型的键执行
	1. `SET`、`GET`、`APPEND`、`STRLEN`等命令只能对字符串键执行
	2. `HDEL`、`HSET`、`HGET`、`HLEN`等命令只能对哈希键执行
	3. `RPUSH`、`LPOP`、`LINSERT`、`LLEN`等命令只能对列表键执行
	4. `SADD`、`SPOP`、`SINTER`、`SCARD`等命令只能对集合键执行
	5. `ZADD`、`ZCARD`、`ZRANK`、`ZSCORE`等命令只能对有序集合键执行

### 类型检查的实现
为了确保只有制定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。类型特定命令所进行的类型检查是通过`redisObject`结构的`type`属性来实现的

执行一个类型特定命令前，先检查值对象是否为执行命令所需的类型：
1. 如果是的话，服务器就对键执行指定的命令
2. 否则，服务器将拒绝执行命令，并向客户端返回一个类型错误

### 多态命令的实现
Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。

## 内存回收
因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。
```c
typedef struct redisObject {  
  
    // ...  
  
    // 引用计数  
    int refcount;  
  
    // ...  
  
} robj;
```
对象的引用计数信息会随着对象的使用状态而不断变化：
1. 在创建一个新对象时，引用计数的值会被初始化为1
2. 当对象被一个新程序使用时，它的引用计数值会被增1
3. 当对象不再被一个程序使用时，它的引用计数值会被减1
4. 当对象的引用计数值变为0时，对象所占用的内存会被释放

## 对象共享
为了节约内存，Redis中的对象可以被多个键共享。目前Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从`0`到`9999`的所有整数值，当服务器需要用到值为`0`到`9999`的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。

在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：
1. 将数据库键的值指针指向一个现有的值对象
2. 将被共享的值对象的引用计数增一

这些共享对象不单单只有字符串键可以使用，那些在数据结构中嵌套了字符串对象的对象都可以使用这些共享对象：
1. `linkedlist`编码的列表对象
2. `hashtable`编码的哈希对象
3. `hashtable`编码的集合对象
4. `zset`编码的有序集合对象

### 为什么Redis只对包含整数值的字符串对象进行共享?
当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的CPU时间也会越多：
1. 如果共享对象是保存整数值的字符串对象，那么验证操作的复杂度为`O(1)`
2. 如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为`O(N)`
3. 如果共享对象包含了多个值对象，那么验证操作的复杂度将会是N的平方

## 对象的空转时长
`redisObject`结构包含`lru`属性，该属性记录了对象最后一次被命令程序访问的时间。

`OBJECT IDLETIME`命令可以打印出键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的`lru`时间计算得出的。当然这个命令访问键的值对象时，不会修改值对象的`lru`属性。

如果服务器打开了`maxmemory`选项，并且服务器用于回收内存的算法为：
1. `volatile-lru`
2. `allkeys-lru`

那么当服务器占用的内存数超过了`maxmemory`选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。




